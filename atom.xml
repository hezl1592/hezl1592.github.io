<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zilch个人博客</title>
  
  <subtitle>博客,Hexo,车辆工程,Linux</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-01T13:39:51.057Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zilch</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python笔记</title>
    <link href="http://yoursite.com/2020/04/01/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/01/python%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-01T12:36:12.000Z</published>
    <updated>2020-04-01T13:39:51.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-eval"><a href="#1-eval" class="headerlink" title="1. eval"></a>1. eval</h3><p>eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。即变量赋值时，等号右边的表示是写成字符串的格式，返回值就是这个表达式的结果。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><ul><li>expression – 表达式。</li><li>globals – 变量作用域，全局命名空间，如果被提供，则必须是<strong>一个字典对象</strong>。</li><li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul><ol><li><p>简单表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(eval(<span class="string">'1 + 2'</span>))<span class="comment"># 3</span></span><br><span class="line">print(eval(<span class="string">'(1 + 2) * 3'</span>))<span class="comment"># 9</span></span><br></pre></td></tr></table></figure></li><li><p>传递全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(eval(<span class="string">"&#123;'name':'linux','age':age&#125;"</span>,&#123;<span class="string">"age"</span>:<span class="number">1822</span>&#125;))</span><br><span class="line"><span class="comment"># &#123;'name': 'linux', 'age': 1822&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>传递本地变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age=<span class="number">18</span></span><br><span class="line">print(eval(<span class="string">"&#123;'name':'linux','age':age&#125;"</span>,&#123;<span class="string">"age"</span>:<span class="number">1822</span>&#125;,locals()))</span><br><span class="line"><span class="comment"># &#123;'name':'linux','age':18&#125;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-eval&quot;&gt;&lt;a href=&quot;#1-eval&quot; class=&quot;headerlink&quot; title=&quot;1. eval&quot;&gt;&lt;/a&gt;1. eval&lt;/h3&gt;&lt;p&gt;eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。即变量赋值时，等号
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python命名空间和作用域</title>
    <link href="http://yoursite.com/2020/04/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/04/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-04-01T12:00:10.000Z</published>
    <updated>2020-04-01T13:40:38.791Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1. 命名空间"></a>1. 命名空间</h3><p>命名空间(namespace)一词，时常出现在C/C++程序开发中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>所谓namespace，是指标识符的各种可见范围。C++标准程序库中的所有标识符都被定义于一个名为<strong>std</strong>的namespace中。我们一般用命名空间来区分同名的不同变量或函数。</p><p>在python的学习中，无意间命名空间的概念在一定程度上被弱化。实际上，在python同样存在着命名空间的概念，命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p><p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p><p>python中一般有三种命名空间：</p><ul><li><strong>内置名称（built-in names）</strong>， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</li></ul><p>python中命名空间查找顺序：<strong>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p><p>python的全局名字空间存储在一个叫<strong>globals()</strong>的dict对象中；局部名字空间存储在一个叫<strong>locals()</strong>的dict对象中。可以用print (locals())来查看该函数体内的所有变量名和变量值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"局部作用域下："</span>)</span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line">print(<span class="string">"全局作用域下："</span>)</span><br><span class="line">print(globals())</span><br><span class="line">print(locals())</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">全局作用域下：</span><br><span class="line">&#123;...（省略很多信息）, 'n': 1, 'test': &lt;function test at 0x00000182E55E3E18&gt;&#125;</span><br><span class="line">&#123;...（省略很多信息）, 'n': 1, 'test': &lt;function test at 0x00000182E55E3E18&gt;&#125;</span><br><span class="line">局部作用域下：</span><br><span class="line">&#123;'n': 2&#125;</span><br></pre></td></tr></table></figure><p>命名空间的生命周期：</p><p>命名空间的生命周期取决于对象的<strong>作用域</strong>，如果对象执行完成，则该命名空间的生命周期就结束。因此，我们无法从外部命名空间访问内部命名空间的对象。</p><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python作用域一共4种，分别是：</p><ul><li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数/方法内部。</li><li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类）A里面又包含了一个函数B，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li><li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li><li><strong>B（Built-in）</strong>：包含了内建的变量/关键字等，最后被搜索。</li></ul><p>查找顺序： <strong>L –&gt; E –&gt; G –&gt; B</strong></p><p>python引入新的作用域：</p><p><strong>只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域</strong>，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line">print(i)</span><br><span class="line"><span class="comment">#以下为输出结果</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>而在C/C++中，代码块中的局部变量会随着代码块的运行结束而释放，不能访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i;   <span class="comment">// 出错：'i' was not declared in this scope</span></span><br></pre></td></tr></table></figure><p>当内部作用域想修改外部作用域的变量时，就要用到<strong>global</strong>和<strong>nonlocal</strong>关键字了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num<span class="comment">#global声明num变量为全局变量</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">print(num)<span class="comment"># 1  </span></span><br><span class="line">change_num()</span><br><span class="line">print(num)<span class="comment"># 100</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_num</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        num = <span class="number">10</span><span class="comment"># 仅改变了enclosing作用域，外层非全局作用域</span></span><br><span class="line">    print(num)<span class="comment"># 100</span></span><br><span class="line">    inner()</span><br><span class="line">    print(num)<span class="comment"># 10</span></span><br><span class="line">change_num()</span><br><span class="line">print(num) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-命名空间&quot;&gt;&lt;a href=&quot;#1-命名空间&quot; class=&quot;headerlink&quot; title=&quot;1. 命名空间&quot;&gt;&lt;/a&gt;1. 命名空间&lt;/h3&gt;&lt;p&gt;命名空间(namespace)一词，时常出现在C/C++程序开发中。&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-03-31T06:11:07.000Z</published>
    <updated>2020-03-31T08:24:35.004Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有<strong>重复子问题</strong>和<strong>最优子结构</strong>的问题。</p><ul><li><p>如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就具备<strong>最优子结构</strong></p></li><li><p>如果计算最优解时需要处理很多相同的问题，那么这个问题就具备<strong>重复子问题</strong></p></li></ul><p>当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个<strong>memory</strong>来缓存重复子问题的结果，<strong>避免了递归的过程中的大量的重复计算</strong>。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的。</p><p>当要应用动态规划来解决问题时，归根结底就是想办法完成以下三个关键目标。</p><ol><li>建立状态转移方程</li></ol><p>这一步通常是最难的…，状态之间的关系。例如<strong>斐波那契数列</strong>，状态转移方程为：<code>f(n)=f(n-1)+f(n-2)</code></p><ol start="2"><li><p>缓存把那个复用以往结果</p></li><li><p>按顺序从小往大算</p></li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>看看最简单的斐波那契数列：0,1,1,2,3 …… 从第0项开始，<code>f(n) = f(n-1)+f(n-2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统的递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划形式#1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_1</span><span class="params">(n)</span>:</span></span><br><span class="line">    memory = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        memory.append(memory[i - <span class="number">1</span>] + memory[i - <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划#2递归形式</span></span><br><span class="line">memory = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">if</span> n &gt;= len(memory):</span><br><span class="line">        memory.append(fibo_dp_2(n - <span class="number">1</span>) + fibo_dp_2(n - <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br></pre></td></tr></table></figure><p>当计算的数较小时：三种方式花费时间差距并不大：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span>, res = <span class="number">55</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">0.000063</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000011</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000014</span>sec</span><br></pre></td></tr></table></figure><p>当计算的数较大时，耗时差距就体现出来，动态规划<strong>缓存</strong>的重要性便凸显出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">37</span>, res = <span class="number">24157817</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">16.511701</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000026</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000044</span>sec</span><br></pre></td></tr></table></figure><p>动态规划速度的快，是因为它将之前的小问题的结果保存在缓存中，而传统的递归方式，相当于重复计算小问题，因此耗时。</p><p><img src="%E4%BC%A0%E7%BB%9F%E9%80%92%E5%BD%92.jpg" alt="image-20200331161524036"></p><p>当然这只是动态规划的最简单形式，动态规划的Leetcode专栏：</p><p><a href="https://leetcode-cn.com/tag/dynamic-programming/" target="_blank" rel="noopener">leetcode/动态规划</a></p><p>唉….我太菜了，很多时候找不到状态转移关系…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有&lt;strong&gt;重复子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就具
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>A-star算法</title>
    <link href="http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T05:09:56.000Z</published>
    <updated>2020-03-30T08:01:28.574Z</updated>
    
    <content type="html"><![CDATA[<p>A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。</p><blockquote><p>本文动图、内容来源：<a href="https://www.jianshu.com/u/12532d36e4da" target="_blank" rel="noopener">阿里云云栖号</a></p></blockquote><h3 id="路径规划的一些算法"><a href="#路径规划的一些算法" class="headerlink" title="路径规划的一些算法"></a>路径规划的一些算法</h3><ol><li>广度优先搜索算法</li></ol><p>BFS（Breadth first search）从起点开始，首先遍历起点周围临近点，然后在遍历已经遍历过的点未访问过的临近点，逐步向外扩散，直到找到终点。BFS以广度为优先级进行搜索。</p><p><img src="BFS" alt="图片加载中"></p><ol start="2"><li>dijkstra算法</li></ol><p>Dijkstra算法用来寻找图形中节点之间的最短路径。Dijkstra算法可以视作BFS算法的带权版本，增加了路径代价的概念。算法执行过程中，每次都从优先级队列中选出代价最小的作为下一个点，直到到达终点。</p><p><img src="dijkstra" alt></p><ol start="3"><li>最佳优先搜索</li></ol><p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p><p>与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p><p><img src="bestfs_good" alt></p><p>但是这样也会出现不良情况，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</p><p><img src="bestfs_bad" alt></p><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>A*算法实际上是综合上面这些算法的特点于一身的。</p><p>A*算法通过下面这个函数来计算每个节点的优先级。</p><p><code>f(n)=g(n)+h(n)</code></p><p>在上式中：</p><ul><li><code>f(n)</code>为节点n的综合优先级；</li><li><code>g(n)</code>为节点n距离起点的代价；</li><li><code>h(n)</code>为节点n距离终点的预计代价。</li></ul><p>上式即为A*算法的启发函数。A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。</p><p>另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为<code>open_set</code>和<code>close_set</code>。完整的A*算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 初始化open_set和close_set；</span><br><span class="line">* 将起点加入open_set中，并设置优先级为0（优先级最高）；</span><br><span class="line">* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span><br><span class="line">    * 如果节点n为终点，则：</span><br><span class="line">        * 从终点开始逐步追踪parent节点，一直达到起点；</span><br><span class="line">        * 返回找到的结果路径，算法结束；</span><br><span class="line">    * 如果节点n不是终点，则：</span><br><span class="line">        * 将节点n从open_set中删除，并加入close_set中；</span><br><span class="line">        * 遍历节点n所有的邻近节点：</span><br><span class="line">            * 如果邻近节点m在close_set中，则：</span><br><span class="line">                * 跳过，选取下一个邻近节点</span><br><span class="line">            * 如果邻近节点m也不在open_set中，则：</span><br><span class="line">                * 设置节点m的parent为节点n</span><br><span class="line">                * 计算节点m的优先级</span><br><span class="line">                * 将节点m加入open_set中</span><br></pre></td></tr></table></figure><p>上面已经提到，启发函数会影响A*算法的行为。</p><ul><li>在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时<strong>算法就退化成了Dijkstra算法</strong>。</li><li>如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。</li><li>如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li><li>如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li><li>在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。</li></ul><p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p><p>对于网格形式的图，有以下这些启发函数可以使用：</p><ul><li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。<code>C</code>为移动代价</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> C * (dx+dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝八个方向移动，则可以使用对角距离。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> D * (dx + dy) + (D2 - <span class="number">2</span> * D) * min(dx, dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</li></ul><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h3><p>虽然 Ａ ＊ 算法能有效解决最短路径问题，但其存在易陷入“死循环”、规划路径折点多、在动态环境中规划效果不佳等问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。&lt;/p&gt;
&lt;blo
      
    
    </summary>
    
    
    
      <category term="A*" scheme="http://yoursite.com/tags/A/"/>
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T01:11:56.000Z</published>
    <updated>2020-03-30T05:15:39.621Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中<strong>不存在负权边</strong>。用于求图中指定两点之间的<strong>最短路径</strong>，或者是<strong>指定一点到其它</strong>所有点之间的最短路径。实质上是<strong>贪心算法</strong>。</p><p>Dijkstra算法可以说是BFS（宽度优先搜索算法）的升级版，BFS的实现可以依靠队列实现，而Dijkstra算法可以通过优先级队列进行实现。</p><p><img src="2012073019540660.gif" alt="图片加载中"></p><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1. 算法描述"></a>1. 算法描述</h3><p><strong>Dijkstra算法</strong>利用贪心策略，从起始点开始出发，选择距离当前位置最近的点加入路径。</p><p>因此算法用到两个集合：</p><ol><li>当前路径中已有点的集合</li><li>当前路径中未包含点的集合</li></ol><p><strong>原理：</strong>Dijkstra的大致思想就是，根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合，集合中所有的点的d[i]都是该点到初始点最短路径长度，由于后加入的点是根据集合S中的点为基础拓展的，所以也能找到最短路径。</p><p>1.将图上的初始点看作一个集合S，其它点看作另一个集合</p><p>2.根据初始点，求出其它点到初始点的距离d[i] （若相邻，则d[i]为边权值；若不相邻，则d[i]为无限大）</p><p>3.选取最小的d[i]（记为d[x]），并将此d[i]边对应的点（记为x）加入集合S</p><p>4.再根据x，更新跟 x 相邻点 y 的d[y]值：d[y] = min{ d[y], d[x] + 边权值w[x][y] }，因为可能把距离调小，所以这个更新操作叫做<strong>松弛操作</strong>。</p><p>5.重复3，4两步，直到目标点也加入了集合，此时目标点所对应的d[i]即为最短路径长度。</p><p>较好理解的视频：（用优先级队列实现）</p><p><a href="https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中&lt;strong&gt;不存在负权边&lt;/strong&gt;。
      
    
    </summary>
    
    
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>测试图片</title>
    <link href="http://yoursite.com/2020/03/29/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2020/03/29/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</id>
    <published>2020-03-29T11:27:06.000Z</published>
    <updated>2020-03-29T14:16:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片</p><p><img src="zentree_1.png" alt="zentree_1"><br><img src="zentree_1.png" alt="zentree_1"></p><p><img src="test.jpg" alt="zentree_1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上
      
    
    </summary>
    
    
    
      <category term="测试图片" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="http://yoursite.com/2020/03/29/hello/"/>
    <id>http://yoursite.com/2020/03/29/hello/</id>
    <published>2020-03-29T10:49:59.000Z</published>
    <updated>2020-03-29T10:51:30.203Z</updated>
    
    <content type="html"><![CDATA[<p>今天成功利用hexo构建个人博客，由GitHub page进行托管</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天成功利用hexo构建个人博客，由GitHub page进行托管&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="启程" scheme="http://yoursite.com/tags/%E5%90%AF%E7%A8%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zilch个人博客</title>
  
  <subtitle>博客,Hexo,车辆工程,Linux</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-23T07:16:21.990Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zilch</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习 | Strip Pooling</title>
    <link href="http://yoursite.com/2020/06/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Strip-Pooling/"/>
    <id>http://yoursite.com/2020/06/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Strip-Pooling/</id>
    <published>2020-06-23T06:39:54.000Z</published>
    <updated>2020-06-23T07:16:21.990Z</updated>
    
    <content type="html"><![CDATA[<p>论文名称：Strip Pooling: Rethinking Spatial Pooling for Scene Parsing</p><p>论文链接：<a href="https://arxiv.org/abs/2003.13328" target="_blank" rel="noopener">https://arxiv.org/abs/2003.13328</a></p><p>GitHub：<a href="https://github.com/Andrew-Qibin/SPNet" target="_blank" rel="noopener">https://github.com/Andrew-Qibin/SPNet</a></p><h3 id="1-摘要"><a class="markdownIt-Anchor" href="#1-摘要"></a> 1 摘要</h3><p>事实证明，空间池可有效捕获用于场景分析等像素级预测任务的远程上下文信息。在本文中，除了通常具有规则形状N×N的常规空间池化之外，我们还通过引入一种称为条带池化的新池化策略来重新考虑空间池化的公式，该策略考虑了一个长而窄的核，即1×N或N×1。基于条带化池，我们进一步研究空间池化体系结构的设计，方法是：1）引入一个新的条带池化模块，该模块使骨干网络能够有效地对远程依赖性进行建模； 2）展示具有多种空间池化的新型构建块；3）系统地比较建议的条带池和常规空间池技术的性能。两种新颖的基于池的设计都是轻量级的，并且可以在现有场景解析网络中用作有效的即插即用模块。在流行的基准（例如ADE20K和Cityscapes）上进行的大量实验表明，我们的简单方法建立了最新的技术成果。</p><h3 id="2-论文内容"><a class="markdownIt-Anchor" href="#2-论文内容"></a> 2 论文内容</h3><h4 id="模块效果图"><a class="markdownIt-Anchor" href="#模块效果图"></a> 模块效果图</h4><p style="text-align:center">    <img src="Snipaste_2020-06-23_14-54-03.jpg" width="40%">    <img src="Snipaste_2020-06-23_14-54-37.jpg" width="40%"></p><h4 id="spmstrip-pooling-module"><a class="markdownIt-Anchor" href="#spmstrip-pooling-module"></a> SPM(Strip Pooling Module)</h4><p>SPM由两条路径组成，它们分别侧重于沿着水平和垂直空间两个维度捕获远程上下文。</p><p>与全局平均池化相比，条纹池化考虑的是较长但较窄的范围，而不是整个特征图，避免了在相距较远的位置之间建立不必要的连接。与需要大量计算来建立每对位置之间关系的基于注意力的模块（no-local ）相比，SPM是轻量级的，可以很容易地嵌入到任何构建块中，从而提高捕获远程空间依赖关系和利用通道间依赖项的能力。</p><p style="text-align:center">    <img src="Snipaste_2020-06-23_14-57-16.jpg" width="70%"></p><h4 id="mpmmixed-pooling-module"><a class="markdownIt-Anchor" href="#mpmmixed-pooling-module"></a> MPM(mixed pooling module)</h4><ul><li>如果因为上面的考虑将网络中的所有pooling全部换成strip pooling操作，则必然会影响原来的非长条物体的效果，就得不偿失了。因此，作者将strip pooling和pyramid pooling都加入进来，构造成mixed pooling module</li><li>其中，strip pooling用于解决long-range dependencies，而轻量级的pyramid pooling用于解决short-range dependencies</li></ul><p>作者提出了一种新的附加组件块，称为混合池模块(MPM)，以进一步在高语义级别上建模长期依赖关系。它通过利用具有不同内核形状的池化操作来探测具有复杂场景的图像，从而收集有用的上下文信息。之前的研究结果表明，金字塔池模型(pyramid pooling module, PPM)是增强语义分割网络的有效方法。然而，PPM严重依赖于标准的池化操作(尽管不同的池内核位于不同的金字塔级别)。考虑到标准池化和条纹池化的优点，作者改进了PPM，提出了混合池模块(MPM)，它侧重于通过各种池化操作聚合不同类型的上下文信息，以使特征表示更有辨别力。</p><p style="text-align:center">    <img src="Snipaste_2020-06-23_15-09-18.jpg" width="40%"></p><h3 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripPooling</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Reference:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_channels, pool_size, norm_layer, up_kwargs)</span>:</span></span><br><span class="line">        super(StripPooling, self).__init__()</span><br><span class="line">        self.pool1 = nn.AdaptiveAvgPool2d(pool_size[<span class="number">0</span>])</span><br><span class="line">        self.pool2 = nn.AdaptiveAvgPool2d(pool_size[<span class="number">1</span>])</span><br><span class="line">        self.pool3 = nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="literal">None</span>))</span><br><span class="line">        self.pool4 = nn.AdaptiveAvgPool2d((<span class="literal">None</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        inter_channels = int(in_channels/<span class="number">4</span>)</span><br><span class="line">        self.conv1_1 = nn.Sequential(nn.Conv2d(in_channels, inter_channels, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(inter_channels), nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        self.conv1_2 = nn.Sequential(nn.Conv2d(in_channels, inter_channels, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(inter_channels), nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        self.conv2_0 = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(inter_channels))</span><br><span class="line">        self.conv2_1 = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(inter_channels))</span><br><span class="line">        self.conv2_2 = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(inter_channels))</span><br><span class="line">        self.conv2_3 = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, (<span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>, (<span class="number">0</span>, <span class="number">1</span>), bias=<span class="literal">False</span>), norm_layer(inter_channels))</span><br><span class="line">        self.conv2_4 = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, (<span class="number">3</span>, <span class="number">1</span>), <span class="number">1</span>, (<span class="number">1</span>, <span class="number">0</span>), bias=<span class="literal">False</span>), norm_layer(inter_channels))</span><br><span class="line">        self.conv2_5 = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(inter_channels), nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        self.conv2_6 = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(inter_channels), nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        self.conv3 = nn.Sequential(nn.Conv2d(inter_channels*<span class="number">2</span>, in_channels, <span class="number">1</span>, bias=<span class="literal">False</span>), norm_layer(in_channels))</span><br><span class="line">        <span class="comment"># bilinear interpolate options</span></span><br><span class="line">        self._up_kwargs = up_kwargs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        _, _, h, w = x.size()</span><br><span class="line">        x1 = self.conv1_1(x)</span><br><span class="line">        x2 = self.conv1_2(x)</span><br><span class="line">        x2_1 = self.conv2_0(x1)</span><br><span class="line">        x2_2 = F.interpolate(self.conv2_1(self.pool1(x1)), (h, w), **self._up_kwargs)</span><br><span class="line">        x2_3 = F.interpolate(self.conv2_2(self.pool2(x1)), (h, w), **self._up_kwargs)</span><br><span class="line">        x2_4 = F.interpolate(self.conv2_3(self.pool3(x2)), (h, w), **self._up_kwargs)</span><br><span class="line">        x2_5 = F.interpolate(self.conv2_4(self.pool4(x2)), (h, w), **self._up_kwargs)</span><br><span class="line">        x1 = self.conv2_5(F.relu_(x2_1 + x2_2 + x2_3))</span><br><span class="line">        x2 = self.conv2_6(F.relu_(x2_5 + x2_4))</span><br><span class="line">        out = self.conv3(torch.cat([x1, x2], dim=<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> F.relu_(x + out)</span><br></pre></td></tr></table></figure><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><blockquote><p><a href="https://www.cnblogs.com/xiangs/p/12747816.html" target="_blank" rel="noopener">论文笔记-Strip Pooling: Rethinking Spatial Pooling for Scene Parsing</a></p><p><a href="https://zhuanlan.zhihu.com/p/122571198" target="_blank" rel="noopener">CVPR2020-语义分割：Strip Pooling（条纹池化）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文名称：Strip Pooling: Rethinking Spatial Pooling for Scene Parsing&lt;/p&gt;
&lt;p&gt;论文链接：&lt;a href=&quot;https://arxiv.org/abs/2003.13328&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>开发 | Docker</title>
    <link href="http://yoursite.com/2020/06/03/%E5%BC%80%E5%8F%91_Docker/"/>
    <id>http://yoursite.com/2020/06/03/%E5%BC%80%E5%8F%91_Docker/</id>
    <published>2020-06-03T03:35:12.000Z</published>
    <updated>2020-06-03T11:15:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker容器的特点:</p><ul><li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li><li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li><li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li></ul><h3 id="docker基本概念"><a class="markdownIt-Anchor" href="#docker基本概念"></a> Docker基本概念</h3><h4 id="1-三个基本概念"><a class="markdownIt-Anchor" href="#1-三个基本概念"></a> 1. 三个基本概念：</h4><ul><li><p>镜像（Image）</p><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</p><p>Docker镜像是一个<strong>特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li><li><p>容器（Container）</p><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是<strong>镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等 。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p></li><li><p>仓库（Repository）</p><p><strong>集中存放镜像文件的地方</strong>，镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以<strong>latest</strong>作为默认标签，例如：<code>java:latest</code>。</p></li></ul><h4 id="2-buildshiprun"><a class="markdownIt-Anchor" href="#2-buildshiprun"></a> 2. Build，Ship，Run</h4><ul><li>Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。</li><li>Ship（运输镜像）：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li>Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><h3 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h3><h4 id="ubuntu1804"><a class="markdownIt-Anchor" href="#ubuntu1804"></a> Ubuntu18.04</h4><ul><li><p>安装依赖项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加官方GPG公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>设置稳定库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure></li><li><p>安装Docker Engine</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></li></ul><h3 id="docker镜像使用"><a class="markdownIt-Anchor" href="#docker镜像使用"></a> Docker镜像使用</h3><h4 id="1docker镜像库"><a class="markdownIt-Anchor" href="#1docker镜像库"></a> 1.Docker镜像库</h4><p>可以替换为国内源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash">添加</span></span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn/","https://hub-mirror.c.163.com","https://registry.docker-cn.com"],</span><br><span class="line">"insecure-registries": ["10.0.0.12:5000"]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重启docker服务</span></span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><h4 id="2docker命令"><a class="markdownIt-Anchor" href="#2docker命令"></a> 2.Docker命令</h4><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><blockquote><p><a href="https://www.cnblogs.com/holaworld/p/12718538.html" target="_blank" rel="noopener">Docker在Ubuntu上安装与使用</a></p><p><a href="https://www.cnblogs.com/wang50902/p/11378202.html" target="_blank" rel="noopener">DOCKER镜像PULL不下来最终解决方法</a></p><p><a href="http://dockone.io/article/6051" target="_blank" rel="noopener">可能是把Docker的概念讲的最清楚的一篇文章</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 是一个开源的应用容器引擎，基于 &lt;a href=&quot;https://www.runoob.com/go/go-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 语言&lt;/a&gt; 并遵从 Apache2.0 协议开源。D
      
    
    </summary>
    
    
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>开发 | VScode远程开发</title>
    <link href="http://yoursite.com/2020/06/03/%E5%BC%80%E5%8F%91_vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2020/06/03/%E5%BC%80%E5%8F%91_vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</id>
    <published>2020-06-03T03:35:12.000Z</published>
    <updated>2020-06-06T03:41:12.305Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Remote development插件</li><li>连接远程服务</li><li></li></ul><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><blockquote><p><a href="https://www.jianshu.com/p/0f2fb935a9a1" target="_blank" rel="noopener">VScode Remote 远程开发与调试</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Remote development插件&lt;/li&gt;
&lt;li&gt;连接远程服务&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考&quot;&gt;&lt;/a&gt; 参考&lt;/h3&gt;
&lt;blockqu
      
    
    </summary>
    
    
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="远程" scheme="http://yoursite.com/tags/%E8%BF%9C%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>目标检测 | Yolo</title>
    <link href="http://yoursite.com/2020/05/18/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B_Yolo/"/>
    <id>http://yoursite.com/2020/05/18/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B_Yolo/</id>
    <published>2020-05-18T01:40:51.000Z</published>
    <updated>2020-05-18T05:42:14.823Z</updated>
    
    <content type="html"><![CDATA[<p>YOLO的全拼是You Only Look Once，顾名思义就是只看一次，把目标区域预测和目标类别预测合二为一，该方法采用单个神经网络直接预测物品边界和类别概率，实现端到端的物品检测。</p><h3 id="yolo-v1"><a class="markdownIt-Anchor" href="#yolo-v1"></a> Yolo v1</h3><p>这是YOLO系列的第一篇，文章发表在CVPR2016上，论文链接:<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf" target="_blank" rel="noopener">YOLOV1</a>.</p><p>摘要指出了文章的主要创新之处：把分类问题转换为回归问题，使用一个卷积神经网络就可以直接预测物体的bounding box和类别概率。<br>算法的优点有很多：</p><ol><li>速度快，Titan X: 45fps。加速版则能达到150fps。</li><li>基于全局信息检测而不是生成region proposal的方法，可以将背景误检率降低一半（把背景识别成物体）。</li><li>泛化能力较强，在艺术作品上有较好的结果。</li></ol><p style="text-align:center">    <img src="yolov1.jpg" alt width="60%"></p><p style="text-align:center">    <img src="yolov1_1.jpg" alt width="60%"></p><h3 id="yolo-v2"><a class="markdownIt-Anchor" href="#yolo-v2"></a> Yolo v2</h3><p style="text-align:center">    <img src="yolov2.jpg" alt width="60%"></p><h3 id="yolo-v3"><a class="markdownIt-Anchor" href="#yolo-v3"></a> Yolo v3</h3><p style="text-align:center">    <img src="yolov3.jpg" alt width="60%"></p><h3 id="yolo-v4"><a class="markdownIt-Anchor" href="#yolo-v4"></a> Yolo v4</h3><p style="text-align:center">    <img src="yolov4.jpg" alt width="60%"></p><ol><li>主干特征提取网络：DarkNet53 =&gt; CSPDarkNet53</li><li>特征金字塔：SPP，PANet</li><li>分类回归层：YOLOv3（未改变）</li><li>训练用到的小技巧：Mosaic数据增强、Label Smoothing平滑、CIOU、学习率余弦退火衰减</li><li>激活函数：使用Mish激活函数</li></ol><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h3><blockquote><p><a href="https://www.jianshu.com/p/a1e618795b29" target="_blank" rel="noopener">12.YOLO系列算法详解1:YOLOV1</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;YOLO的全拼是You Only Look Once，顾名思义就是只看一次，把目标区域预测和目标类别预测合二为一，该方法采用单个神经网络直接预测物品边界和类别概率，实现端到端的物品检测。&lt;/p&gt;
&lt;h3 id=&quot;yolo-v1&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="Yolo" scheme="http://yoursite.com/tags/Yolo/"/>
    
  </entry>
  
  <entry>
    <title>有限状态机</title>
    <link href="http://yoursite.com/2020/05/12/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/05/12/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2020-05-12T01:05:08.000Z</published>
    <updated>2020-05-12T15:01:06.219Z</updated>
    
    <content type="html"><![CDATA[<p>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p><p>其实我们在编程时实现相关业务逻辑时经常需要处理各种事件和状态切换，写各种switch/case 和if/else ，所以我们其实可能一直都在跟有限状态机打交道，只是可能没有意识到。在处理一些业务逻辑比较复杂的需求时，可以先看看是否适合用一个有限状态机来描述，如果可以把业务模型抽象成一个有限状态机，那么代码就会逻辑特别清晰，结构特别规整。</p><p>使用有限状态机应遵循的假设：1系统的状态是有限的，2状态的转移是瞬间的。</p><p>在描述有限状态机是，状态、事件、转换和动作是经常遇到的基本概念。</p><ul><li><strong>状态</strong>（state）指的是对象在其生命周期中的一种状况，处于某个特定状态中的对象必然会满足某些条件、执行某些动作或者是等待某些事件。</li><li><strong>事件</strong>（Event）指的是在时间和空间上占有一定位置，并且对状态机来讲是有意义的那些事情。事件通常会引起状态的变迁，促使状态机从一种状态切换到另一种状态。</li><li><strong>转换</strong>（<em>Transition</em>）指的是两个状态之间的一种关系，表明对象将在第一个状态中执行一定的动作，并将在某个事件发生同时某个特定条件满足时进入第二个状态。</li><li>**动作（<em>Action</em>）**指的是状态机中可以执行的那些原子操作，所谓原子操作指的是它们在运行的过程中不能被其他消息所中断，必须一直执行下去。</li></ul><p>一个简单的基于有限状态机的车辆驾驶行为决策。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。&lt;/p&gt;
&lt;p&gt;其实我们在编程时实现相关业务逻辑时经常需要处理各种事件和状态切换，写各种switch/case 和if/else ，所以我们其实
      
    
    </summary>
    
    
    
      <category term="决策" scheme="http://yoursite.com/tags/%E5%86%B3%E7%AD%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ | const限定符</title>
    <link href="http://yoursite.com/2020/04/26/C++_const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/04/26/C++_const%E9%99%90%E5%AE%9A%E7%AC%A6/</id>
    <published>2020-04-26T06:25:59.000Z</published>
    <updated>2020-04-26T08:04:51.484Z</updated>
    
    <content type="html"><![CDATA[<p>const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p><p>C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。</p><h3 id="1-const修饰普通类型变量"><a class="markdownIt-Anchor" href="#1-const修饰普通类型变量"></a> 1. const修饰普通类型变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;<span class="comment">//编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = get_size();<span class="comment">//正确，运行时初始化</span></span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">//正确</span></span><br><span class="line">a = <span class="number">12</span>;<span class="comment">//错误，不可修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c;<span class="comment">//错误，const定义必须初始化</span></span><br></pre></td></tr></table></figure><p>默认情况下，const对象尽在文件中有效；</p><p>如果想在多个文件中共享const对象，必须在变量的定义之前条件extern关键字；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = func();</span><br><span class="line"><span class="comment">//file2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br></pre></td></tr></table></figure><h3 id="2-const的引用"><a class="markdownIt-Anchor" href="#2-const的引用"></a> 2. const的引用</h3><p>可以将引用绑定在const对象上，就像绑定在其他对象上一样，称之为<strong>对常量的引用（reference to const）</strong>。和普通引用不同，对常量的引用不能被用作修改他所绑定的对象；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;<span class="comment">//正确</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;<span class="comment">//错误，试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure><p>对const的引用可能引用一个并非const的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line"></span><br><span class="line">i = <span class="number">32</span>;<span class="comment">//正确赋值，此时r2也随之改变为32；</span></span><br></pre></td></tr></table></figure><p>上述表示不允许通过r2来修改i的值，但是<code>i</code>的值仍可以通过其他途径进行修改。</p><h3 id="3-指针和const"><a class="markdownIt-Anchor" href="#3-指针和const"></a> 3. 指针和const</h3><p><code>const</code>修饰指针变量有以下三种情况。</p><ul><li>A: <code>const</code>修饰指针指向的内容，则内容为不可变量。</li><li>B: <code>const</code>修饰指针，则指针为不可变量。</li><li>C: <code>const</code>修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li></ul><p>如同引用，可以令指针指向常量和非常量，类似于常量引用，**指向常量的指针（pointer to const）**不能用于改变其所指对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;<span class="comment">//错误，ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;<span class="comment">//正确</span></span><br><span class="line">*cptr = <span class="number">42</span>;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.21</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;dval;<span class="comment">//正确</span></span><br><span class="line">dval = <span class="number">3.14</span>;<span class="comment">//正确，*cptr也修改</span></span><br></pre></td></tr></table></figure><p>则指针指向的内容不可改变。简称左定值，因为 const 位于 * 号的左边。</p><h4 id="const指针"><a class="markdownIt-Anchor" href="#const指针"></a> const指针</h4><p>指针是对象而引用不是，因此可以向其他对象一样，允许将指针本身定为常量。**const指针（const pointer）**必须初始化，而且一旦初始化完成后，则该指针的值（存放在指针中的地址）就不能再改变了。把*放在const关键字之前用于说明指针是一个常量，即不变的是指针本身的值而非指向的那个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;<span class="comment">//curErr一直指向errNumb</span></span><br><span class="line"></span><br><span class="line">*curErr = <span class="number">1</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">double</span> newErr = <span class="number">13</span>;</span><br><span class="line">curErr = &amp;newErr;<span class="comment">//不正确</span></span><br></pre></td></tr></table></figure><p>对于 const 指针其指向的内存地址不能够被改变，但其内容可以改变。简称，<strong>右定向</strong>。因为 const 位于 * 号的右边。</p><p>第三种情况就是前两者的结合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;<span class="comment">//pip是一个指向常量对象的常量指针。</span></span><br></pre></td></tr></table></figure><p>这时，const指针的指向的内容和指向的内存地址都已固定，不可改变。</p><h3 id="4-顶层const与底层const"><a class="markdownIt-Anchor" href="#4-顶层const与底层const"></a> 4. 顶层const与底层const</h3><ul><li>顶层const：表示任意对象本身就是一个常量；</li><li>底层const：与指针和引用等复合类型的基本类型部分有关，如指针所指对象是一个常量；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i<span class="comment">//不能改变p1本身的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">//不能改变p2的值，这是一个底层const</span></span><br></pre></td></tr></table></figure><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。&lt;/p&gt;
&lt;p&gt;C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 卷积操作参数量和计算量</title>
    <link href="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Pytorch_%E5%8F%82%E6%95%B0%E9%87%8F&amp;%E8%AE%A1%E7%AE%97%E9%87%8F/"/>
    <id>http://yoursite.com/2020/04/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_Pytorch_%E5%8F%82%E6%95%B0%E9%87%8F&amp;%E8%AE%A1%E7%AE%97%E9%87%8F/</id>
    <published>2020-04-22T06:20:34.000Z</published>
    <updated>2020-04-22T08:39:50.302Z</updated>
    
    <content type="html"><![CDATA[<p>卷积神经网络在图像处理中的地位已然毋庸置疑。卷积运算具备强大的特征提取能力、相比全连接又消耗更少的参数，应用在图像这样的二维结构数据中有着先天优势。</p><h3 id="1-常规卷积运算"><a class="markdownIt-Anchor" href="#1-常规卷积运算"></a> 1. 常规卷积运算</h3><p>假设输入层为一个大小为64×64像素、三通道彩色图片。经过一个包含4个Filter的卷积层，最终输出4个Feature Map，且尺寸与输入层相同。整个过程可以用下图来概括。</p><p>input：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>C</mi><mrow><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mtext></mrow></msub><mo separator="true">,</mo><mi>H</mi><mo separator="true">,</mo><mi>W</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(N, C_{\text{in}}, H, W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="text mord scriptstyle cramped"><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span>，output：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>C</mi><mrow><mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext></mrow></msub><mo separator="true">,</mo><msub><mi>H</mi><mrow><mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext></mrow></msub><mo separator="true">,</mo><msub><mi>W</mi><mrow><mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(N, C_{\text{out}}, H_{\text{out}}, W_{\text{out}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="text mord scriptstyle cramped"><span class="mord mathrm">o</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="text mord scriptstyle cramped"><span class="mord mathrm">o</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="text mord scriptstyle cramped"><span class="mord mathrm">o</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext><mo>(</mo><msub><mi>N</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>C</mi><mrow><msub><mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext><mi>j</mi></msub></mrow></msub><mo>)</mo><mo>=</mo><mtext><mi mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi></mtext><mo>(</mo><msub><mi>C</mi><mrow><msub><mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext><mi>j</mi></msub></mrow></msub><mo>)</mo><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><msub><mi>C</mi><mrow><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mtext></mrow></msub><mo>−</mo><mn>1</mn></mrow></msubsup><mtext><mi mathvariant="normal">w</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">t</mi></mtext><mo>(</mo><msub><mi>C</mi><mrow><msub><mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext><mi>j</mi></msub></mrow></msub><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>⋆</mo><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi></mtext><mo>(</mo><msub><mi>N</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{out}(N_i, C_{\text{out}_j}) = \text{bias}(C_{\text{out}_j}) +        \sum_{k = 0}^{C_{\text{in}} - 1} \text{weight}(C_{\text{out}_j}, k) \star \text{input}(N_i, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.8443360000000002em;"></span><span class="strut bottom" style="height:3.1464490000000005em;vertical-align:-1.302113em;"></span><span class="base displaystyle textstyle uncramped"><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">o</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.14999999999999997em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="text mord scriptstyle cramped"><span class="mord mathrm">o</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">a</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.14999999999999997em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="text mord scriptstyle cramped"><span class="mord mathrm">o</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mop op-limits"><span class="vlist"><span style="top:1.202113em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span><span style="top:-0.000005000000000032756em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span style="top:-1.266005em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="text mord scriptscriptstyle cramped"><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">e</span><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">h</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.14999999999999997em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="text mord scriptstyle cramped"><span class="mord mathrm">o</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mbin">⋆</span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">p</span><span class="mord mathrm">u</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p><p style="text-align:center">    <img src="conv_1.gif" width="22%">    <img src="conv.jpg" width="50%"></p><ul><li><p><strong>图片卷积输出大小计算公式</strong></p><p>输入图像大小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>W</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(C_{in}, W_{in},H_{in})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，卷积核Filter大小：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>F</mi><mo separator="true">,</mo><mi>F</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(F,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span>，步长：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>，填充<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">padding</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">⌊</mo><mfrac><mrow><msub><mi>H</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mn>2</mn><mo>×</mo><mi>P</mi><mo>−</mo><mi>F</mi></mrow><mrow><mtext><mi mathvariant="normal">S</mi></mtext></mrow></mfrac><mo>+</mo><mn>1</mn><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">H_{out} = \left\lfloor\frac{H_{in}  + 2 \times P - F}{\text{S}} + 1\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.45em;"></span><span class="strut bottom" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="minner displaystyle textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm">S</span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">⌊</mo><mfrac><mrow><msub><mi>W</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mn>2</mn><mo>×</mo><mi>P</mi><mo>−</mo><mi>F</mi></mrow><mrow><mtext><mi mathvariant="normal">S</mi></mtext></mrow></mfrac><mo>+</mo><mn>1</mn><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">W_{out} = \left\lfloor\frac{W_{in}  + 2 \times P - F}{\text{S}} + 1\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.45em;"></span><span class="strut bottom" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="minner displaystyle textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm">S</span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span></span></span></span></span></p></li><li><p><strong>参数量</strong></p><p>假设一个卷积核的大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>K</mi><mo separator="true">,</mo><mi>K</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(K,K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>，输入的特征图为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><mi>H</mi><mo separator="true">,</mo><mi>W</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(C_{in}, H, W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span>，输入为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>C</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>W</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(C_{out}, H_{out},W_{out})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，不考虑偏置，不补0的卷积。参数量为（即卷积核个数*卷积核参数+偏置数）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>×</mo><mi>K</mi><mo>×</mo><mi>K</mi><mo>×</mo><msub><mi>C</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{in} \times K\times K\times C_{out}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p></li><li><p><strong>计算量</strong></p><p>MAC(Multiply Accumulate)，需要考虑输出map的大小，1个MAC算两次操作</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>×</mo><mi>K</mi><mo>×</mo><msub><mi>W</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>×</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>×</mo><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>C</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K\times K \times W_{out} \times H_{out}\times C_{in}\times C_{out}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p></li><li><p><strong>示例</strong></p><ul><li>输入维度:（6, 64, 64），卷积核:（3, 3），padding=1，stride=1；</li><li>输出shape：(3, 64, 64)；</li><li>参数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mo>=</mo><mn>6</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>1</mn><mn>6</mn><mn>2</mn></mrow><annotation encoding="application/x-tex">params = 6\times 3\times 3\times 3 = 162</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mord mathrm">6</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mord mathrm">2</span></span></span></span></li><li>计算量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>p</mi><mi>s</mi><mo>=</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>6</mn><mn>4</mn><mo>×</mo><mn>6</mn><mn>4</mn><mo>×</mo><mn>6</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>6</mn><mn>6</mn><mn>3</mn><mn>5</mn><mn>5</mn><mn>2</mn></mrow><annotation encoding="application/x-tex">flops=3\times 3\times 64\times 64\times 6\times 3=663552</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mrel">=</span><span class="mord mathrm">6</span><span class="mord mathrm">6</span><span class="mord mathrm">3</span><span class="mord mathrm">5</span><span class="mord mathrm">5</span><span class="mord mathrm">2</span></span></span></span></li></ul><p>用Pytorch展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchsummary</span><br><span class="line"><span class="keyword">import</span> thop</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_ch, out_ch, group=<span class="number">1</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=in_ch, out_channels=out_ch,</span><br><span class="line">                               groups=group, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,</span><br><span class="line">                               padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = BaseNet(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">input_tensor = torch.rand(<span class="number">1</span>,<span class="number">6</span>,<span class="number">64</span>,<span class="number">64</span>)</span><br><span class="line">input_size = tuple(input_tensor.shape[<span class="number">1</span>:])</span><br><span class="line">torchsummary.summary(model, input_size=input_size, batch_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"thop:"</span>)</span><br><span class="line">flops, params = thop.profile(model=model, inputs=(input_tensor,))</span><br><span class="line">print(flops, params)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------</span><br><span class="line">        Layer (type)               Output Shape         Param <span class="comment">#</span></span><br><span class="line">================================================================</span><br><span class="line">            Conv2d<span class="number">-1</span>             [<span class="number">1</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>]             <span class="number">162</span></span><br><span class="line">================================================================</span><br><span class="line">Total params: <span class="number">162</span></span><br><span class="line">Trainable params: <span class="number">162</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">Input size (MB): <span class="number">0.09</span></span><br><span class="line">Forward/backward <span class="keyword">pass</span> size (MB): <span class="number">0.09</span></span><br><span class="line">Params size (MB): <span class="number">0.00</span></span><br><span class="line">Estimated Total Size (MB): <span class="number">0.19</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">thop:</span><br><span class="line">[INFO] Register count_convNd() <span class="keyword">for</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">torch</span>.<span class="title">nn</span>.<span class="title">modules</span>.<span class="title">conv</span>.<span class="title">Conv2d</span>'&gt;.</span></span><br><span class="line"><span class="class">[<span class="title">WARN</span>] <span class="title">Cannot</span> <span class="title">find</span> <span class="title">rule</span> <span class="title">for</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">BaseNet</span>'&gt;. <span class="title">Treat</span> <span class="title">it</span> <span class="title">as</span> <span class="title">zero</span> <span class="title">Macs</span> <span class="title">and</span> <span class="title">zero</span> <span class="title">Params</span>.</span></span><br><span class="line"><span class="class">663552.0 162.0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-分组卷积"><a class="markdownIt-Anchor" href="#2-分组卷积"></a> 2. 分组卷积</h3><p><strong>分组卷积(Group Convolution)</strong>：常规卷积的计算结果中，特征图的每个通道和输入特征图的<strong>所有通道</strong>都有关。下方左图是普通卷积的示意图，下放右图是分组卷积的示意图，差别就非常明显了。分组卷积的输出特征图的每个通道，只和输入特征图的一部分通道有关，而这部分通道，就是一个分组(Group)。</p><p>依旧假设输入特征图的尺寸为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>×</mo><mi>H</mi><mo>×</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">C_{in} \times H \times W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.13889em;">W</span></span></span></span>，分为3组进行分组卷积，那么，对于每一组，输出特征图的通道数都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">C_{out}/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">3</span></span></span></span>，卷积核大小变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>×</mo><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">C_{in} \times K \times K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>，最后只需要将各个分组的计算结果按照通道进行连接(Cat)即可。</p><p style="text-align:center;margin:0 auto;">    <img src="conv_group_1.png" width="25%">    <img src="conv_group_2.png" width="25%"></p><p>分组卷积可以很大程度上减少卷积所需的参数量，相同的输入输出特征图，分组卷积所需的参数量为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>×</mo><mi>K</mi><mo>×</mo><mi>K</mi><mo>×</mo><msub><mi>C</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><mrow><mn>3</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{C_{in} \times K\times K\times C_{out}}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">3</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>即，分组卷积可将参数量减少为原来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">1/G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit">G</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">G</span></span></span></span>为分组数量。</p><p style="text-align:center;margin:0 auto;">    <img src="conv_group_3.png" width="30%">    <img src="conv_group_4.png" width="30%"></p><p>分组卷积最早出现在AlexNet中，如下图所示。在CNN发展初期，GPU资源不足以满足训练任务的要求，因此，Hinton采用了多GPU训练的策略，每个GPU完成一部分卷积，最后把多个GPU的卷积结果进行融合。</p><ul><li><p><strong>代码实例</strong></p><ul><li>输入维度:（6, 64, 64），卷积核:（3, 3），padding=1，stride=1, group=3;</li><li>输出shape：(3, 64, 64)；</li><li>参数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>(</mo><mn>6</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>3</mn><mo>=</mo><mn>5</mn><mn>4</mn></mrow><annotation encoding="application/x-tex">params = (6\times 3\times 3\times 3) /3= 54</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathrm">6</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathrm">3</span><span class="mrel">=</span><span class="mord mathrm">5</span><span class="mord mathrm">4</span></span></span></span></li><li>计算量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>p</mi><mi>s</mi><mo>=</mo><mo>(</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>6</mn><mn>4</mn><mo>×</mo><mn>6</mn><mn>4</mn><mo>×</mo><mn>6</mn><mo>×</mo><mn>3</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>3</mn><mo>=</mo><mn>2</mn><mn>2</mn><mn>1</mn><mn>1</mn><mn>8</mn><mn>4</mn></mrow><annotation encoding="application/x-tex">flops=(3\times 3\times 64\times 64\times 6\times 3)/3=221184</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathrm">3</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">2</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">8</span><span class="mord mathrm">4</span></span></span></span></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_ch, out_ch, group=<span class="number">1</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=in_ch, out_channels=out_ch,</span><br><span class="line">                               groups=group, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,</span><br><span class="line">                               padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">model = BaseNet(<span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">input_tensor = torch.rand(<span class="number">1</span>,<span class="number">6</span>,<span class="number">64</span>,<span class="number">64</span>)</span><br><span class="line">input_size = tuple(input_tensor.shape[<span class="number">1</span>:])</span><br><span class="line">torchsummary.summary(model, input_size=input_size, batch_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"thop:"</span>)</span><br><span class="line">flops, params = thop.profile(model=model, inputs=(input_tensor,))</span><br><span class="line">print(flops, params)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------</span><br><span class="line">        Layer (type)               Output Shape         Param #</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">            Conv2d-1             [1, 3, 64, 64]              54</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Total params: 54</span><br><span class="line">Trainable params: 54</span><br><span class="line">Non-trainable params: 0</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">Input size (MB): 0.09</span><br><span class="line">Forward&#x2F;backward pass size (MB): 0.09</span><br><span class="line">Params size (MB): 0.00</span><br><span class="line">Estimated Total Size (MB): 0.19</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">thop:</span><br><span class="line">[INFO] Register count_convNd() for &lt;class &#39;torch.nn.modules.conv.Conv2d&#39;&gt;.</span><br><span class="line">[WARN] Cannot find rule for &lt;class &#39;__main__.BaseNet&#39;&gt;. Treat it as zero Macs and zero Params.</span><br><span class="line">221184.0 54.0</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-深度可分离卷积"><a class="markdownIt-Anchor" href="#3-深度可分离卷积"></a> 3. 深度可分离卷积</h3><p><strong>深度可分离卷积(DepthwiseSeparable Convolution)</strong>，在Google的<code>Xception</code>以及<code>MobileNet</code>论文中均有描述。它的核心思想是将一个完整的卷积运算分解为两步进行，分别为<code>Depthwise Convolution</code>与<code>Pointwise Convolution</code>。</p><p style="text-align:center;margin:0 auto;">    <img src="conv_dw_sp_1.png" width="40%">    <img src="conv_dw_sp.png" width="40%"></p><ul><li><p><strong>Depthwise Convolution</strong></p><p>当分组卷积（Group Convolution）的group等于输入map维度时，分组卷积就变成了depthwise卷积：</p><p style="text-align:center;margin:0 auto;">    <img src="conv_depthwise.png" width="50%"></p></li><li><p><strong>Pointwise Convolution</strong></p><p>Pointwise Convolution的运算与<strong>常规卷积运算</strong>非常相似，它的卷积核的尺寸为<strong>1×1×M</strong>，M为上一层的通道数。所以这里的卷积运算会将上一步的map在深度方向上进行加权组合，生成新的Feature map。有几个卷积核就有几个输出Feature map。如下图所示：</p><p style="text-align:center;margin:0 auto;">    <img src="conv_depthwise_1.png" width="50%"></p></li><li><p><strong>代码实例</strong></p><ul><li>输入维度:（6, 64, 64），卷积核:（3, 3），padding=1，stride=1, group=3;</li><li>输出shape：(3, 64, 64)；</li><li>参数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>(</mo><mn>6</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>)</mo><mo>+</mo><mo>(</mo><mn>6</mn><mo>×</mo><mn>3</mn><mo>)</mo><mo>=</mo><mn>7</mn><mn>2</mn></mrow><annotation encoding="application/x-tex">params = (6\times 3\times 3)+(6\times3)= 72</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathrm">6</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mclose">)</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathrm">6</span><span class="mbin">×</span><span class="mord mathrm">3</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">7</span><span class="mord mathrm">2</span></span></span></span></li><li>计算量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>p</mi><mi>s</mi><mo>=</mo><mn>2</mn><mn>9</mn><mn>4</mn><mn>9</mn><mn>1</mn><mn>2</mn></mrow><annotation encoding="application/x-tex">flops=294912</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">s</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">9</span><span class="mord mathrm">4</span><span class="mord mathrm">9</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span></span></span></span></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseNet_DWCONV_sp</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_ch, out_ch, group)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="comment"># depthwise</span></span><br><span class="line">    self.dwconv = nn.Conv2d(in_channels=in_ch, out_channels=in_ch,</span><br><span class="line">                                groups=in_ch, kernel_size=<span class="number">3</span>,</span><br><span class="line">                                stride=<span class="number">1</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># pointwise</span></span><br><span class="line">    self.poconv = nn.Conv2d(in_channels=in_ch, out_channels=out_ch,</span><br><span class="line">                                kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.dwconv(x)</span><br><span class="line">        x = self.poconv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = BaseNet_DWCONV_sp(<span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">input_tensor = torch.rand(<span class="number">1</span>,<span class="number">6</span>,<span class="number">64</span>,<span class="number">64</span>)</span><br><span class="line">input_size = tuple(input_tensor.shape[<span class="number">1</span>:])</span><br><span class="line">torchsummary.summary(model, input_size=input_size, batch_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"thop:"</span>)</span><br><span class="line">flops, params = thop.profile(model=model, inputs=(input_tensor,))</span><br><span class="line">print(flops, params)</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------</span><br><span class="line">        Layer (type)               Output Shape         Param <span class="comment">#</span></span><br><span class="line">================================================================</span><br><span class="line">            Conv2d<span class="number">-1</span>             [<span class="number">1</span>, <span class="number">6</span>, <span class="number">64</span>, <span class="number">64</span>]              <span class="number">54</span></span><br><span class="line">            Conv2d<span class="number">-2</span>             [<span class="number">1</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>]              <span class="number">18</span></span><br><span class="line">================================================================</span><br><span class="line">Total params: <span class="number">72</span></span><br><span class="line">Trainable params: <span class="number">72</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">Input size (MB): <span class="number">0.09</span></span><br><span class="line">Forward/backward <span class="keyword">pass</span> size (MB): <span class="number">0.28</span></span><br><span class="line">Params size (MB): <span class="number">0.00</span></span><br><span class="line">Estimated Total Size (MB): <span class="number">0.38</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">thop:</span><br><span class="line">[INFO] Register count_convNd() <span class="keyword">for</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">torch</span>.<span class="title">nn</span>.<span class="title">modules</span>.<span class="title">conv</span>.<span class="title">Conv2d</span>'&gt;.</span></span><br><span class="line"><span class="class">[<span class="title">WARN</span>] <span class="title">Cannot</span> <span class="title">find</span> <span class="title">rule</span> <span class="title">for</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">BaseNet_DWCONV_sp</span>'&gt;. <span class="title">Treat</span> <span class="title">it</span> <span class="title">as</span> <span class="title">zero</span> <span class="title">Macs</span> <span class="title">and</span> <span class="title">zero</span> <span class="title">Params</span>.</span></span><br><span class="line"><span class="class">294912.0 72.0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-空洞卷积"><a class="markdownIt-Anchor" href="#4-空洞卷积"></a> 4. 空洞卷积</h3><p>这部分待完善…</p><p>**空洞卷积(atrous convolutions)**又名扩张卷积（dilated convolutions），向卷积层引入了一个称为 “<strong>扩张率(dilation rate)</strong>”的新参数，该参数定义了卷积核处理数据时各值的间距。</p><p><strong>空洞卷积(Dilated/Atrous Convolution</strong>)，广泛应用于语义分割与目标检测等任务中，语义分割中经典的<strong>deeplab系列与DUC</strong>对空洞卷积进行了深入的思考。目标检测中<strong>SSD与RFBNet</strong>，同样使用了空洞卷积。</p><p style="text-align:center">    <img src="conv_atrous.gif" width="30%"></p><p>在相同的计算条件下，空洞卷积提供了更大的感受野。空洞卷积经常用在实时<strong>图像分割</strong>中。当网络层需要较大的感受野，但计算资源有限而无法提高卷积核数量或大小时，可以考虑空洞卷积。</p><ul><li><strong>空洞卷积的作用</strong><ul><li><strong>扩大感受野</strong>：在deep net中为了增加感受野且降低计算量，总要进行降采样(pooling或s2/conv)，这样虽然可以增加感受野，但空间分辨率降低了。为了能不丢失分辨率，且仍然扩大感受野，可以使用空洞卷积。这在检测，分割任务中十分有用。一方面感受野大了可以检测分割大目标，另一方面分辨率高了可以精确定位目标。</li><li>**捕获多尺度上下文信息：**空洞卷积有一个参数可以设置dilation rate，具体含义就是在卷积核中填充dilation rate-1个0，因此，当设置不同dilation rate时，感受野就会不一样，也即获取了多尺度信息。<strong>多尺度信息在视觉任务中相当重要啊。</strong></li></ul></li></ul><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><blockquote><p><a href="https://blog.csdn.net/tintinetmilou/article/details/81607721" target="_blank" rel="noopener">Depthwise卷积与Pointwise卷积</a></p><p><a href="https://www.cnblogs.com/shine-lee/p/10243114.html" target="_blank" rel="noopener">Group Convolution分组卷积，以及Depthwise Convolution和Global Depthwise Convolution</a></p><p><a href="https://cloud.tencent.com/developer/article/1453992" target="_blank" rel="noopener">卷积网络基础知识—Depthwise Convolution &amp;&amp; Pointwise Convolution &amp;&amp; Separable Convolution</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;卷积神经网络在图像处理中的地位已然毋庸置疑。卷积运算具备强大的特征提取能力、相比全连接又消耗更少的参数，应用在图像这样的二维结构数据中有着先天优势。&lt;/p&gt;
&lt;h3 id=&quot;1-常规卷积运算&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-常规
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 分类模型评价指标</title>
    <link href="http://yoursite.com/2020/04/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>http://yoursite.com/2020/04/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</id>
    <published>2020-04-20T08:21:34.000Z</published>
    <updated>2020-04-20T15:25:42.321Z</updated>
    
    <content type="html"><![CDATA[<p>在深度学习领域，常用的评价指标：</p><p>准确率 （Accuracy），混淆矩阵 （Confusion Matrix），精确率（Precision），召回率（Recall），平均正确率（AP），mean Average Precision(mAP)，交并并（IoU），ROC + AUC，非极大值抑制（NMS）。</p><p>在了解这些指标之前，我们需要明白一下定义（通俗语言解释）：</p><p>假设被检测物体为汽车；</p><ul><li><strong>TP</strong> (True Positive）：被正确检测为汽车；</li><li><strong>FP</strong>（False Positive）：被错误检测为汽车（实际不是汽车）；</li><li><strong>FN</strong>（False Negative）：未被检测为汽车，实际是汽车（错误检测）；</li><li><strong>TN</strong>（True Negative）：正确检测不是汽车；(基本不会使用)</li></ul><p>请记住：<code>P(Positive)</code>和<code>N(Negative)</code>代表<strong>模型的判断结果</strong>；<code>T(True)</code>和<code>F(False)</code>评价<strong>模型的判断结果是否正确</strong>。</p><p>在图像分类任务中，判断的正确与否很好区分，在目标检测任务中，可以这样理解：</p><ul><li><strong>TP</strong> (True Positive)：一个正确的检测，检测的IOU ≥ <em>threshold</em>。即预测的边界框(bounding box)中分类正确且边界框坐标正确的数量。</li><li><strong>FP</strong> (False Positive)：一个错误的检测，检测的IOU &lt; <em>threshold</em>。**即预测的边界框中分类错误或者边界框坐标不达标的数量，**即预测出的所有边界框中除去预测正确的边界框，剩下的边界框的数量。</li><li><strong>FN</strong> (False Negative)：一个没有被检测出来的<code>ground truth</code>。所有没有预测到的边界框的数量，即正确的边界框(ground truth)中除去被预测正确的边界框，剩下的边界框的数量。</li></ul><h3 id="1-准确率"><a class="markdownIt-Anchor" href="#1-准确率"></a> 1. 准确率</h3><p><strong>准确率</strong>（Accuracy），所有预测正确的样本 / 总的样本：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Accuracy=\frac{TP+TN}{TP+FP+TN+FN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit">c</span><span class="mord mathit">c</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>准确率一般用来评估模型的全局准确程度，不能包含太多信息，<strong>无法全面评价</strong>一个模型性能。</p><h3 id="2-精确率"><a class="markdownIt-Anchor" href="#2-精确率"></a> 2. 精确率</h3><p><strong>精确率</strong>（precision），也称为查准率，准确率是模型<strong>只找到</strong>相关目标的能力。通俗来说，你认为的正样本，有多少猜对了（<strong>猜的准确性如何</strong>），精确率是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是真正的正样本。准确率可以反映一个类别的预测正确率 。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Precision=\frac{TP}{TP+FP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><h3 id="3-召回率"><a class="markdownIt-Anchor" href="#3-召回率"></a> 3. 召回率</h3><p><strong>召回率</strong>（recall），也称为查全率，是模型<strong>找到所有</strong>相关目标的能力，即模型给出的预测结果最多能覆盖多少真实目标。通俗解释：正样本有多少被找出来了（<strong>召回了多少</strong>），召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Recall=\frac{TP}{TP+FN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>区分好召回率和精确率的关键在于：针对的数据不同，<strong>召回率针对的是数据集中的所有正例，精确率针对的是模型判断出的所有正例</strong>。</p><p><strong>一般来说，对于多分类目标检测的任务，会分别计算每个类别的TP、FP、FN数量，进一步计算每个类别的Precision、Recall。</strong></p><h3 id="4-f-值"><a class="markdownIt-Anchor" href="#4-f-值"></a> 4. F-值</h3><p><strong>F1</strong>是基于精确率和召回率的<strong>调和平均</strong>，又称为<strong>F-Score</strong>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo>⋅</mo><mo>(</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>P</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>R</mi></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{F_1}=\frac{1}{2}\cdot (\frac{1}{P}+\frac{1}{R})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.1574400000000002em;vertical-align:-0.8360000000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">⋅</span><span class="mopen">(</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mn>1</mn><mo>=</mo><mfrac><mrow><mn>2</mn><mo>×</mo><mi>P</mi><mo>×</mo><mi>R</mi></mrow><mrow><mi>P</mi><mo>+</mo><mi>R</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mi>T</mi><mi>P</mi></mrow><mrow><mn>2</mn><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">F1=\frac{2\times P\times R}{P+R}=\frac{2TP}{2TP+FP+FN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">2</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><h3 id="5-pr曲线"><a class="markdownIt-Anchor" href="#5-pr曲线"></a> 5. PR曲线</h3><p>准确率和召回率是互相影响的，因为如果想要提高准确率就会把预测的置信率阈值调高，所有置信率较高的预测才会被显示出来，而那一些正确正预测（True Positive）可能因为置信率比较低而没有被显示了。一般情况下准确率高、召回率就低，召回率低、准确率高，如果两者都低，就是网络出问题了。一般情况，用不同的阀值，统计出一组不同阀值下的精确率和召回率。</p><p>如果一个分类器的性能比较好，那么它应该有如下的表现：在Recall值增长的同时，Precision的值保持在一个很高的水平。而性能比较差的分类器可能会损失很多Precision值才能换来Recall值的提高。</p><p><strong>PR曲线</strong>（Precision x Recall curve），所有precision-recall点相连形成的曲线(一般会为每个类别的预测框建立各自的PR曲线)。通常情况下，文章中都会使用Precision-recall曲线，来显示出分类器在Precision与Recall之间的权衡。</p><p style="text-align:center">    <img src="PR曲线.png" width="60%"></p><p>通常，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo separator="true">,</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P,R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>均是针对一组测试集而言，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">PR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>曲线也是针对一组测试集而言。假如模型针对某一目标种类，测试集为5张图片，有以下预测结果。其中总共预测出9个目标，实际目标有6个。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo separator="true">,</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P,R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>计算以及PR曲线绘制如下：</p><p style="text-align:center">    <img src="pr-.jpg" width="50%"></p><h3 id="6-ap-map"><a class="markdownIt-Anchor" href="#6-ap-map"></a> 6. AP、mAP</h3><p><strong>平均精度（Average-Precision，AP）</strong>，就是<strong>Precision-recall 曲线下面的面积</strong>，通常来说一个越好的分类器，AP值越高。</p><p><strong>mean Average Precision(mAP)</strong>，是所有类别AP的平均值。这个mean的意思是对每个类的AP求和再求平均，得到的就是mAP的值。mAP的大小一定在[0,1]区间，<strong>越大越好</strong>。该指标是目标检测算法中最重要的一个。</p><h3 id="7-iou"><a class="markdownIt-Anchor" href="#7-iou"></a> 7. IoU</h3><p><strong>交并比</strong>（Intersection-over-Union，IoU），是产生的候选框（candidate bound）与原标记框（ground truth bound）的交叠率，即<strong>它们的交集与并集的比值</strong>。</p><p style="text-align:center">    <img src="Iou.png" width="40%"></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">I</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">U</mi></mtext><mo>=</mo><mfrac><mrow><mi>C</mi><mo>∩</mo><mi>G</mi></mrow><mrow><mi>C</mi><mo>∪</mo><mi>G</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text {IoU}=\frac{C\cap G}{C\cup G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">I</span><span class="mord mathrm">o</span><span class="mord mathrm">U</span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mbin">∪</span><span class="mord mathit">G</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mbin">∩</span><span class="mord mathit">G</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>IoU正是表达这种<strong>bounding box</strong>和<strong>groundtruth</strong>的差异的指标。最理想情况是完全重叠，即比值为1。</p><h3 id="8-roc曲线"><a class="markdownIt-Anchor" href="#8-roc曲线"></a> 8. ROC曲线</h3><p><strong>ROC（Receiver Operating Characteristic）曲线</strong>，曲线的横坐标为<strong>假正例率（FPR）</strong>，纵坐标为<strong>TPR(真正例率)</strong>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">FPR=\frac {FP}{FP+TN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac><mo>=</mo><mi>R</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">TPR=\frac {TP}{TP+FN}=Recall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span></span></p><p><strong>AUC</strong> (Area under Curve)：即ROC曲线下的面积，介于0.1和1之间，作为数值可以直观的评价分类器的好坏，值越大越好。</p><p>ROC曲线也需要相应的阈值才可以进行绘制，原理同上的PR曲线。下图为ROC曲线示意图，因现实任务中通常利用有限个测试样例来绘制ROC图，因此应为无法产生光滑曲线，如右图所示。</p><p style="text-align:center">    <img src="roc&auc.jpg" width="60%"></p><ul><li><p><strong>ROC曲线图中的四个点</strong></p><p>第一个点：(0,1)，即FPR=0, TPR=1，这意味着FN=0，并且FP=0。这是完美的分类器，它将所有的样本都正确分类。</p><p>第二个点：(1,0)，即FPR=1，TPR=0，类似地分析可以发现这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。</p><p>第三个点：(0,0)，即FPR=TPR=0，即FP=TP=0，可以发现该分类器预测所有的样本都为负样本（negative）。</p><p>第四个点：(1,1)，分类器实际上预测所有的样本都为正样本。</p><p>经过以上的分析，ROC曲线越接近左上角，该分类器的性能越好。</p></li></ul><h3 id="9-非极大值抑制nms"><a class="markdownIt-Anchor" href="#9-非极大值抑制nms"></a> 9. 非极大值抑制（NMS）</h3><p><strong>Non-Maximum Suppression</strong>就是需要根据score矩阵和region的坐标信息，从中找到置信度比较高的bounding box。对于有重叠在一起的预测框，只保留得分最高的那个。</p><ol><li>NMS计算出每一个bounding box的面积，然后根据score进行排序，把score最大的bounding box作为队列中首个要比较的对象；</li><li>计算其余bounding box与当前最大score与box的IoU，去除IoU大于设定的阈值的bounding box，保留小的IoU得预测框；</li><li>然后重复上面的过程，直至候选bounding box为空。</li></ol><p>最终，检测了bounding box的过程中有两个阈值，一个就是<strong>IoU</strong>，另一个是在过程之后，从候选的bounding box中剔除score小于阈值的bounding box。需要注意的是：Non-Maximum Suppression<strong>一次处理一个类别</strong>，如果有N个类别，Non-Maximum Suppression就需要执行N次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在深度学习领域，常用的评价指标：&lt;/p&gt;
&lt;p&gt;准确率 （Accuracy），混淆矩阵 （Confusion Matrix），精确率（Precision），召回率（Recall），平均正确率（AP），mean Average Precision(mAP)，交并并（IoU），
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="评价指标" scheme="http://yoursite.com/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>C++ | 多线程</title>
    <link href="http://yoursite.com/2020/04/18/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/18/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-04-18T04:20:00.000Z</published>
    <updated>2020-04-19T05:25:35.036Z</updated>
    
    <content type="html"><![CDATA[<p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p><ul><li>基于进程的多任务处理是程序的并发执行。</li><li>基于线程的多任务处理是同一程序的片段的并发执行。</li></ul><h3 id="1-posix"><a class="markdownIt-Anchor" href="#1-posix"></a> 1. POSIX</h3><p>POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。</p><ul><li><p><strong>创建线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *th, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(* func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>pthread_create</code>创建一个新的线程，并让它可执行。</p><ul><li><p>返回值：成功创建为0；</p></li><li><p>参数：</p><ul><li><code>th</code>：指向线程标识符的指针；</li><li><code>attr</code>：用于设置线程属性，可以使用默认值<code>NULL</code>;</li><li><code>func</code>：线程运行函数起始地址，一旦线程被创建就会执行；</li><li><code>arg</code>：运行函数的参数，它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</li></ul></li></ul></li><li><p><strong>终止线程</strong></p><p>如果需要只终止某个线程而不终止整个进程，可以有三种方法：</p><ol><li>从线程函数<code>return</code>。这种方法对主线程不适用，从main函数return相当于调用 exit 。</li><li>一个线程可以调用<code>pthread_cancel</code>终止同一进程中的另一个线程。</li><li>线程可以调用<code>pthread_exit</code>终止自己。</li></ol><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *res)</span></span>;</span><br></pre></td></tr></table></figure><p><code>res</code>是<code>void *</code>类型，和线程函数返回值的用法一样，其它线程可以调用<code>pthread_join</code>获得这个指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> t, <span class="keyword">void</span> **res)</span></span>;</span><br></pre></td></tr></table></figure><p>调用该函数的线程将挂起等待，直到id为<code>t</code>的线程终止。<code>t</code>线程以不同的方法终止，通过<code>pthread_join</code>得到的终止状态是不同的，总结如下：</p><ol><li>如果<code>t</code>线程通过<code>return</code>返回， <code>res</code>所指向的单元里存放的是 <code>t</code>线程函数的返回值。</li><li>如果<code>t</code>线程被别的线程调用<code>pthread_cancel</code>异常终止掉， <code>res</code> 所指向的单元里存放的是常数<code>PTHREAD_CANCELED</code>。</li><li>如果<code>t</code>线程是自己调用<code>pthread_exit</code>终止的，<code>res</code>所指向的单元存放的是传给<code>pthread_exit</code>的参数。</li></ol></li><li><p><strong>创建与退出线程示例</strong></p><ul><li><p><a href="https://github.com/hezl1592/CCC-/blob/master/7_thread/0_pthread/pthread_1.cpp" target="_blank" rel="noopener">代码示例1</a></p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main thread: pid 26709 tid 3731060480 (0xde637700)</span><br><span class="line">new thread:  pid 26709 tid 3722659584 (0xdde34700)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/hezl1592/CCC-/blob/master/7_thread/0_pthread/pthread_2.cpp" target="_blank" rel="noopener">代码示例2</a></p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread 1 returning</span><br><span class="line">thread 1 exit code 1</span><br><span class="line">thread 2 exiting</span><br><span class="line">thread 2 exit code 2</span><br><span class="line">thread 3 writing</span><br><span class="line">thread 3 writing</span><br><span class="line">thread 3 writing</span><br><span class="line">thread 3 exit code -1</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>向线程传递参数</strong></p><p>向线程传递参数时，涉及数据类型转化，记得进行转化。</p><ul><li><a href="https://github.com/hezl1592/CCC-/blob/master/7_thread/0_pthread/pthread_3.cpp" target="_blank" rel="noopener">代码示例</a></li></ul></li><li><p><strong>线程同步</strong></p><p>线程的最大特点是资源的共享性，但资源共享中的同步问题是多线程编程的难点。linux下提供了多种方式来处理线程同步，最常用的是互斥锁、条件变量和信号量。</p><p><a href="https://github.com/hezl1592/CCC-/tree/master/7_thread/0_pthread/pthread_4" target="_blank" rel="noopener">代码示例</a></p><ul><li><p><strong>互斥锁（mutex）</strong></p><p>通过锁机制实现线程间的同步。同一时刻只允许一个线程执行一个关键部分的代码。</p><p>互斥锁是通过锁的机制来实现线程间的同步问题。互斥锁的基本流程为：</p><ul><li><p>定义，初始化一个互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//声明</span></span><br><span class="line"><span class="keyword">int</span> a = pthread_mutex_init(&amp;counter_mutex, <span class="literal">NULL</span>);<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure></li><li><p>加锁：<code>pthread_mutex_lock()</code>函数或</p></li><li><p><code>pthread_mutex_trylock()</code>函数</p></li><li><p>对共享资源的操作</p></li><li><p>解锁：<code>pthread_mutex_unlock()</code>函数</p></li><li><p>注销互斥锁：<code>pthread_mutex_destory()</code>函数</p></li></ul></li><li><p><strong>条件变量（condition Variable）</strong></p><ul><li><p>定义、初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"><span class="keyword">int</span> res = pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>等待条件变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = pthread_cond_wait(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure><p>**参数说明：**cond 条件变量地址，mutex互斥锁地址，表示锁等待在条件变量上.</p></li><li><p>唤醒等待条件变量上的线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;               <span class="comment">//唤醒等待该条件变量上的某个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;         <span class="comment">//唤醒等待该条件变量上的所有线程</span></span><br></pre></td></tr></table></figure></li><li><p>销毁条件变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>信号量（Semaphore）</strong></p><p>这里先不介绍…</p></li></ul></li><li><p>未完待续</p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：&lt;strong&gt;基于进程和基于线程&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于进程的多任务处理是程序的并发执行。&lt;/li&gt;
&lt;li&gt;基于线程的多任务
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux | Linux指令</title>
    <link href="http://yoursite.com/2020/04/12/Linux%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/04/12/Linux%E6%8C%87%E4%BB%A4/</id>
    <published>2020-04-12T05:59:47.000Z</published>
    <updated>2020-04-12T06:56:29.365Z</updated>
    
    <content type="html"><![CDATA[<p>用Ubuntu系统很久了，记录一下linux系统下常见的指令及其参数。</p><p>参考：<a href="https://www.cnblogs.com/xuxinstyle/p/9609551.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuxinstyle/p/9609551.html</a></p><blockquote><p>Linux，全称GNU/Linux，是一套免费使用和自由传播的类UNIX操作系统。</p></blockquote><h3 id="1-ls"><a class="markdownIt-Anchor" href="#1-ls"></a> 1. ls</h3><p><code>ls</code>命令，展示文件夹内内容，<code>ls</code>常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ </span><br><span class="line">-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ </span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的档案数据 </span><br><span class="line">-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) </span><br><span class="line">-F ：根据档案、目录等信息，给予附加数据结构，例如： </span><br><span class="line">*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； </span><br><span class="line">-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； </span><br><span class="line">-i ：列出 inode 位置，而非列出档案属性； </span><br><span class="line">-l ：长数据串行出，包含档案的属性等等数据； </span><br><span class="line">-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) </span><br><span class="line">-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； </span><br><span class="line">-R ：连同子目录内容一起列出来； </span><br><span class="line">-S ：以档案容量大小排序！ </span><br><span class="line">-t ：依时间排序 </span><br><span class="line">--color=never ：不要依据档案特性给予颜色显示； </span><br><span class="line">--color=always ：显示颜色 </span><br><span class="line">--color=auto ：让系统自行依据设定来判断是否给予颜色 </span><br><span class="line">--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 </span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) </span><br><span class="line">而非内容变更时间 (modification time)</span><br></pre></td></tr></table></figure><p>常用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line">ls -A</span><br></pre></td></tr></table></figure><h3 id="2-cd"><a class="markdownIt-Anchor" href="#2-cd"></a> 2. cd</h3><p>执行进入文件夹命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ./dir</span><br><span class="line">cd /root</span><br><span class="line">cd ..</span><br><span class="line">cd ~</span><br></pre></td></tr></table></figure><h3 id="3-tree"><a class="markdownIt-Anchor" href="#3-tree"></a> 3. tree</h3><p>tree命令，显示树形的层级目录结构，非原生命令，需要安装tree</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree 路径</span></span><br><span class="line">tree ./</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── frp</span><br><span class="line">│   ├── frp.log</span><br><span class="line">│   ├── frps</span><br><span class="line">│   ├── frps_full.ini</span><br><span class="line">│   ├── frps.ini</span><br><span class="line">│   ├── frp_startup.sh</span><br><span class="line">│   ├── LICENSE</span><br><span class="line">│   └── systemd</span><br><span class="line">│       ├── frpc.service</span><br><span class="line">│       ├── frpc@.service</span><br><span class="line">│       ├── frps.service</span><br><span class="line">│       └── frps@.service</span><br></pre></td></tr></table></figure><h4 id="4-cpmv"><a class="markdownIt-Anchor" href="#4-cpmv"></a> 4. cp&amp;mv</h4><ul><li><p>cp 命令，作用复制，参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a ：将文件的特性一起复制</span><br><span class="line">-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</span><br><span class="line">-r ：递归持续复制，用于目录的复制行为</span><br><span class="line">-u ：目标文件与源文件有差异时才会复制</span><br></pre></td></tr></table></figure></li><li><p>mv命令作用为移动文件（重命名）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="line">-i ：若目标文件已经存在，就会询问是否覆盖</span><br><span class="line">-u ：若目标文件已经存在，且比目标文件新，才会更新</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-rm"><a class="markdownIt-Anchor" href="#5-rm"></a> 5. rm</h3><p>rm命令作用为删除，参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="line">-i ：互动模式，在删除前会询问用户是否操作</span><br><span class="line">-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br><span class="line"></span><br><span class="line"># 慎用用</span><br><span class="line">rm -rf *</span><br></pre></td></tr></table></figure><h3 id="6-pwd"><a class="markdownIt-Anchor" href="#6-pwd"></a> 6. pwd</h3><p>pwd命令，作用为查看”当前工作目录“的完整路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd -P # 显示出实际路径，而非使用连接（link）路径；</span><br><span class="line">pwd    # 显示的是连接路径</span><br></pre></td></tr></table></figure><h3 id="7-tar"><a class="markdownIt-Anchor" href="#7-tar"></a> 7. tar</h3><p>tar命令，用于压缩解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c ：新建打包文件</span><br><span class="line">-t ：查看打包文件的内容含有哪些文件名</span><br><span class="line">-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</span><br><span class="line">-j ：通过bzip2的支持进行压缩/解压缩</span><br><span class="line">-z ：通过gzip的支持进行压缩/解压缩</span><br><span class="line">-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</span><br><span class="line">-f filename ：filename为要处理的文件</span><br><span class="line">-C dir ：指定压缩/解压缩的目录dir</span><br></pre></td></tr></table></figure><p>常用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf FileName.tar.gz# 解压缩</span><br><span class="line">tar -zcvf FileName.tar.gz DirName       # 将DirName和其下所有文件（夹）压缩</span><br></pre></td></tr></table></figure><h3 id="8-ps"><a class="markdownIt-Anchor" href="#8-ps"></a> 8. ps</h3><p>ps 命令显示运行的进程，还会显示进程的一些信息如pid, cpu和内存使用情况等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-A ：所有的进程均显示出来</span><br><span class="line">-a ：不与terminal有关的所有进程</span><br><span class="line">-u ：有效用户的相关进程</span><br><span class="line">-x ：一般与a参数一起使用，可列出较完整的信息</span><br><span class="line">-l ：较长，较详细地将PID的信息列出</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">ps aux | grep "xxx"</span><br></pre></td></tr></table></figure><h3 id="9-kill"><a class="markdownIt-Anchor" href="#9-kill"></a> 9. kill</h3><p>kill 命令用于终止进程，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kill -signal PID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">-1：SIGHUP，启动被终止的进程</span><br><span class="line">-2：SIGINT，相当于输入ctrl+c，中断一个程序的进行</span><br><span class="line">-9：SIGKILL，强制中断一个进程的进行</span><br><span class="line">-15：SIGTERM，以正常的结束进程方式来终止进程</span><br><span class="line">-17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用Ubuntu系统很久了，记录一下linux系统下常见的指令及其参数。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/xuxinstyle/p/9609551.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CMAKE | Cmake与开发</title>
    <link href="http://yoursite.com/2020/04/08/%E6%B5%85%E8%B0%88Cmake/"/>
    <id>http://yoursite.com/2020/04/08/%E6%B5%85%E8%B0%88Cmake/</id>
    <published>2020-04-08T06:42:14.000Z</published>
    <updated>2020-04-08T11:03:09.256Z</updated>
    
    <content type="html"><![CDATA[<p>CMake是个一个开源的跨平台<strong>自动化建构</strong>系统，用来管理软件建置的程序，并不相依于某特定编译器。可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的Makefile或者project文件，CMake 并不直接建构出最终的软件，而是产生标准的建构档（如Unix的Makefile或projects），然后再依一般的建构方式使用。</p><h3 id="1-基本模板"><a class="markdownIt-Anchor" href="#1-基本模板"></a> 1. 基本模板</h3><p>Cmake的基础便是<strong>CMakeLists.txt</strong>文件，一般：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment"># 资源目录</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE DIR: "</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置源文件变量, 并添加文件（多个）</span></span><br><span class="line"><span class="comment"># set(src_list xxx.cpp xxx.cpp xx.cpp)</span></span><br><span class="line"><span class="keyword">set</span>(src_list main.cpp <span class="number">1</span>.cpp)</span><br><span class="line"><span class="comment"># 目标可执行文件</span></span><br><span class="line"><span class="comment"># 可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(target_file <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印提示信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE: "</span> <span class="variable">$&#123;src_list&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"TARGET: "</span> <span class="variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/<span class="variable">$&#123;target_file&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"-Wall -std=c++11"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定头文件目录位置</span></span><br><span class="line"><span class="comment"># INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/include)</span></span><br><span class="line"><span class="comment">#添加共享库搜索路径</span></span><br><span class="line"><span class="comment"># LINK_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置头文件位置，相当于g++ -I，可以用相对或绝对路径，也可以用自定义的变量值</span></span><br><span class="line"><span class="comment"># include_directories($&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用给定的源文件，为工程引入一个可执行文件test。</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;target_file&#125;</span> <span class="variable">$&#123;src_list&#125;</span>)</span><br></pre></td></tr></table></figure><p>编译的时候，当源文件很多的时候，可以使用 <code>aux_source_directory</code> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;target_file&#125;</span> <span class="variable">$&#123;src_list&#125;</span>)</span><br></pre></td></tr></table></figure><p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 CMakeDemo的可执行文件。</p><h3 id="2-生成库文件"><a class="markdownIt-Anchor" href="#2-生成库文件"></a> 2. 生成库文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;name&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br></pre></td></tr></table></figure><p><strong>库文件</strong>是事先编译好的方法的合集。比如：我们提前写好一些数据公式的实现，将其打包成库文件，以后使用只需要库文件就可以，不需要重新编写。</p><p>库文件分两种：静态库和动态库（也叫共享库）</p><ul><li>Windows系统静态库扩展名为：.lib，动态库扩展名为.dll；</li><li>Linux系统下静态库的扩展名为.a，<a href="http://xn--siqu1iv4aj0s8zczwcivgp04c.so" target="_blank" rel="noopener">动态库的扩展名为.so</a>；</li></ul><ol><li><strong>Cmake生成静态库</strong></li></ol><p>静态库（也称作归档文件），程序在链接的过程中，链接器从库文件中取得所需代码，复制到生成的可执行文件中。因此，<strong>静态库是在程序员的链接阶段被复制到程序当中</strong>，和程序的执行没有任何关系。</p><p>这类库在编译的时候会<strong>直接整合到目标程序中</strong>，所以利用静态函数库编译成的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE: "</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是关键，生成静态库（默认）</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Cmake生成动态库</strong></li></ol><p>与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序里只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE: "</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是关键，生成动态库！SHARED</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-链接库"><a class="markdownIt-Anchor" href="#3-链接库"></a> 3. 链接库</h3><ul><li><strong>link_directories</strong></li></ul><p>该指令的作用主要是指定要链接的库文件的<strong>路径</strong>，该指令有时候<strong>不一定需要</strong>。因为find_package和find_library指令可以得到库文件的绝对路径。不过你自己写的动态库文件放在自己新建的目录下时，可以用该指令指定该目录的路径以便工程能够找到。</p><ul><li><strong>target_link_libraries</strong></li></ul><p>该指令的作用为将目标文件与库文件进行链接。该指令的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; [item1] [item2] [...]</span><br><span class="line">                      [[debug|optimized|general] &lt;item&gt;] ...)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><p>假设我们需要寻找当前目录中lib/libmath.so，则CMakeLIsts.txt:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加库目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库libmath.so or libmath.a</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="keyword">math</span>)</span><br></pre></td></tr></table></figure><h3 id="4-外部项目"><a class="markdownIt-Anchor" href="#4-外部项目"></a> 4. 外部项目</h3><p>当当前编译的项目需要外部文件支持时，可以将外部文件编译为静态链接库，然后链接到目标，</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加外部文件夹，并执行该文件夹下方的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(sub1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加静态库，sub-&gt;实际中：libsub.a</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target_file&#125;</span> sub)</span><br></pre></td></tr></table></figure><p>同时，外部文件夹sub1中，同样需要CMakeLIsts.txt文件：例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="cmake-clean"><a class="markdownIt-Anchor" href="#cmake-clean"></a> cmake clean</h3><p>cmake没有提供类似Makefile中clean的命令，因此可以在源文件同级目录下写一个Makefile，内容如下：<a href="https://blog.csdn.net/coldplayplay/article/details/78508883?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">CSDN-coldplayplay</a></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BUILD_DIR = ./build</span><br><span class="line">DEST_DIR = ./bin</span><br><span class="line">DEST_EXE_NAME = main</span><br><span class="line"></span><br><span class="line"><span class="section">all: build</span></span><br><span class="line">    cd <span class="variable">$(BUILD_DIR)</span>;  make -j4</span><br><span class="line"><span class="section">run:</span></span><br><span class="line">    cd <span class="variable">$(DEST_DIR)</span>; ./<span class="variable">$(DEST_EXE_NAME)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm <span class="variable">$(BUILD_DIR)</span> -rf</span><br><span class="line"><span class="section">build:</span></span><br><span class="line">    mkdir <span class="variable">$(BUILD_DIR)</span>;cd <span class="variable">$(BUILD_DIR)</span>; cmake ..</span><br></pre></td></tr></table></figure><h3 id="cmake基础部分大概如此更加进阶的基于基础在实战中进步"><a class="markdownIt-Anchor" href="#cmake基础部分大概如此更加进阶的基于基础在实战中进步"></a> cmake基础部分大概如此，更加进阶的基于基础在实战中进步！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CMake是个一个开源的跨平台&lt;strong&gt;自动化建构&lt;/strong&gt;系统，用来管理软件建置的程序，并不相依于某特定编译器。可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的Makefile或者project文件，CMake 并不直接建构出最终的软件
      
    
    </summary>
    
    
    
      <category term="Cmake" scheme="http://yoursite.com/tags/Cmake/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>python | 浅谈Python类</title>
    <link href="http://yoursite.com/2020/04/07/python%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/04/07/python%E7%B1%BB/</id>
    <published>2020-04-07T07:07:18.000Z</published>
    <updated>2020-04-07T08:52:14.838Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/hezl1592/Daily-Python/blob/master/Class/class_1.py" target="_blank" rel="noopener">GitHub代码示例</a></li></ul><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。</p><p>相关名词：</p><ul><li><strong>类（class）</strong>：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法</strong>：类中定义的函数。</li><li><strong>类变量</strong>：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员</strong>：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>局部变量</strong>：定义在方法中的变量，只作用于当前实例的类；</li><li>**实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。</li><li>**实例化：**创建一个类的实例，类的具体对象。</li><li>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h3 id="1-类的定义"><a class="markdownIt-Anchor" href="#1-类的定义"></a> 1. 类的定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    <span class="comment"># .</span></span><br><span class="line">    <span class="comment"># .</span></span><br><span class="line">    &lt;statement-N&gt;</span><br><span class="line">obj = Classname()<span class="comment">#实例化得到对象</span></span><br></pre></td></tr></table></figure><p>类<strong>实例化后</strong>，才可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p><p><strong>类的权限控制</strong></p><ul><li><p>私有属性：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。</p><ul><li>类变量：<code>__privateattrs</code></li><li>实例变量：<code>self.__privateattrs</code></li></ul></li><li><p>私有方法：</p><p><code>__privatemethod</code>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。</p></li></ul><h3 id="2-类对象"><a class="markdownIt-Anchor" href="#2-类对象"></a> 2. 类对象</h3><p>类有一个名为<code>__init__</code>的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用，也就是构造函数。参数通过<code>__init__</code>传递到类的实例化操作上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x1, x2)</span>:</span></span><br><span class="line">        self.x1 = x1</span><br><span class="line">        self.x2 = x2</span><br><span class="line">x = classname(x1,x2)<span class="comment">#实例化为对象</span></span><br></pre></td></tr></table></figure><p>在这里，需要注意的是，<code>self</code>代表类的实例，而非类本身。同时<code>self</code>不是python的关键字，换成其他名称也可以。</p><h3 id="3-类的方法"><a class="markdownIt-Anchor" href="#3-类的方法"></a> 3. 类的方法</h3><p>在类的内部，使用<code>def</code>关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self, 且为第一个参数，self 代表的是类的实例。</strong></p><p><strong>类的专有方法：</strong></p><ul><li><code>__init__</code>：构造函数，在生成对象时调用</li><li><code>__del__</code>：析构函数，释放对象时使用</li><li><code>__repr__</code>：打印，转换。<code>__str__</code>实际上调用了该方法</li><li><code>__setitem__</code>：按照索引赋值</li><li><code>__getitem__</code>：按照索引获取值</li><li><code>__len__</code>：获得长度</li><li><code>__cmp__</code>：比较运算</li><li><code>__call__</code>：函数调用</li><li><code>__add__</code>：加运算</li><li><code>__sub__</code>：减运算</li><li><code>__mul__</code>：乘运算</li><li><code>__truediv__</code>：除运算</li><li><code>__mod__</code>：求余运算</li><li><code>__pow__</code>：乘方</li></ul><p>以上所有的专用方法都可以继承后重写~，我们可以对类的专有方法进行重载</p><h3 id="4-继承"><a class="markdownIt-Anchor" href="#4-继承"></a> 4. 继承</h3><p><strong>Python</strong>同样支持类的继承，派生类的定义如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName1)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(modname.BaseClassName)</span>:</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    __num = <span class="number">0</span><span class="comment">#私有类属性，记录创建对象数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        People.__num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'编号:&#123;&#125;,\t姓名:&#123;&#125;,\t性别:&#123;&#125;'</span>.format(People.__num, self.name, self.gender)</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(People)</span>:</span></span><br><span class="line">    __num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, grade)</span>:</span></span><br><span class="line">        super().__init__(name, gender)</span><br><span class="line">        self.grade = grade</span><br><span class="line">        Student.__num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__str__() + <span class="string">",\t在读&#123;&#125;年级, 学生编号:&#123;&#125;."</span>.format(self.grade, Student.__num)</span><br></pre></td></tr></table></figure><h3 id="5-多继承"><a class="markdownIt-Anchor" href="#5-多继承"></a> 5. 多继承</h3><p>Python同样支持多继承形式。多继承的类定义形如下例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>需要注意圆括号中<strong>父类的顺序</strong>，若是父类中有相同的方法名，而在子类使用时未指定，python从<strong>左至右搜索</strong>即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><p>Python 提供super用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p><p>C++中使用虚拟继承来解决重复调用问题；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hezl1592/Daily-Python/blob/master/Class/class_1.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub代码示例&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
    
    
      <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>C++ | IO标准库&amp;文件操作</title>
    <link href="http://yoursite.com/2020/04/05/C++_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/04/05/C++_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6/</id>
    <published>2020-04-05T07:43:33.000Z</published>
    <updated>2020-04-06T05:13:17.724Z</updated>
    
    <content type="html"><![CDATA[<p>I/O（Input/Output），C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。</p><p>这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。</p><p>为了支持不同类型的IO处理操作，C++的IO类型定义在三个独立的头文件中：（w:宽字符）</p><ul><li>iostream定义了用于读写流的基本类型；<ul><li>istream，wistream从流读取数据</li><li>ostream, wostream向流写入数据</li><li>iostream，wiostream读写流</li></ul></li><li>fstream定义了读写命名文件的类型；<ul><li>ifstream, wifstream从文件读取数据</li><li>ofstream, wofstream项文件写入数据</li><li>fstream,wfstream读写文件</li></ul></li><li>sstream定义了读写内存string对象的类型。<ul><li>istringstream,wistringstream从string读取数据</li><li>ostringstream，wostringstream向string写入数据</li><li>stringstream，wstringstream读写string</li></ul></li></ul><p><strong>常见IO对象</strong>：</p><ul><li><p><code>cin</code>，一个istream对象，从标准输入读取数据。</p></li><li><p><code>cout</code>，一个ostream对象，从标准输出写入数据。</p></li><li><p><code>cerr</code>，一个ostream对象，用于输出错误消息。</p></li><li><p><code>getline</code>函数，从一个给定的输入流读取一行数据存入string对象。</p></li></ul><h3 id="1-使用cout进行输出"><a class="markdownIt-Anchor" href="#1-使用cout进行输出"></a> 1. 使用cout进行输出</h3><p><code>&lt;&lt;</code>运算符的默认含义是按位左移运算符，ostream类将<code>&lt;&lt;</code>重载为输出，在这种情况下，<code>&lt;&lt;</code>被称为插入运算符，能都识别C++中<strong>所有的基本类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">88</span>;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><ul><li><p>输出与指针</p><p>ostream类为下面的指针类型定义了插入运算符函数：</p><ul><li>const signed char *;</li><li>const unsigned char *;</li><li>const char *;</li><li>void *;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> eggs = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">char</span> *amount = <span class="string">"dozen"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;eggs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; amount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span> *)amount &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//字符串的地址</span></span><br></pre></td></tr></table></figure></li><li><p>拼接输出</p><p>插入运算符的返回类型都是ostream &amp;。</p><p>因此:<code>cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl;</code></p></li><li><p>其他ostream方法</p><p>ostream类还提供了<code>put()</code>和<code>write()</code>方法，前者用于显示<strong>字符</strong>，后者用于显示<strong>字符串</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'W'</span>).<span class="built_in">put</span>(<span class="number">65</span>).<span class="built_in">put</span>(<span class="string">'\n'</span>); <span class="comment">//显示字符:WA</span></span><br><span class="line"><span class="built_in">cout</span>.<span class="built_in">write</span>(<span class="string">"Hezil"</span>, <span class="number">3</span>);      <span class="comment">//显示字符串:Hez</span></span><br></pre></td></tr></table></figure></li><li><p>endl, ends, flush;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; ends &lt;&lt; <span class="string">"world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">flush</span> &lt;&lt; <span class="string">"world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-使用cin进行输入"><a class="markdownIt-Anchor" href="#2-使用cin进行输入"></a> 2. 使用cin进行输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">int</span> &amp;);</span><br></pre></td></tr></table></figure><p><code>istream</code>类还为下列字符指针类型重载了&gt;&gt;抽取运算符；</p><ul><li>signed char *;</li><li>char *;</li><li>unsigned char *;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;val)<span class="comment">//判断输入是否为int类型</span></span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>流状态</p><p><code>cin</code>或者<code>cout</code>包含一个描述流状态（stream state）的数据成员（从<code>ios_base</code>类继承而来），由三个<code>ios_base</code>元素组成：<code>eofbit</code>、<code>badbit</code>、<code>failbit</code>。</p><ul><li><p><code>eofbit</code></p><p>如果到达文件尾，则设置为1</p></li><li><p><code>badbit</code></p><p>如果流被破坏，则设置为1，例如：文件读取错误</p></li><li><p><code>failbit</code></p><p>如果输入操作未能读取预期的字符或输出操作没有写入预期的字符，则设置为1；</p></li></ul><p><strong>设置流状态：</strong></p><ul><li><pre class="highlight"><code class="c++"><span class="built_in">clear</span>();<span class="comment">//清楚全部三个状态位</span><span class="built_in">clear</span>(eofbit);setstate(eofbit);&lt;!--￼<span class="number">6</span>--&gt;</code></pre></li></ul></li><li><p>其他istream方法</p><ul><li><p>单字符输入</p><ul><li><code>get(char &amp;)</code>，返回类型为<code>istream &amp;</code>, 到达文件尾的返回值转化为false</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch,ch1;</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch).<span class="built_in">get</span>(ch1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>(ch))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//process input;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>get(void)</code>，返回类型为<code>int</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;<span class="comment">//or char ch</span></span><br><span class="line">ch = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch=<span class="built_in">cin</span>.<span class="built_in">get</span>())!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数适用于放置输入字符串的内存单元地址，第二个参数比要读取的最大字符数大一（额外的一个字符用于存储结尾的空字符串），第三个参数指定用作分界符的字符，只有两个参数的版本将换行符作为默认分界符。</p><ul><li><code>getline()</code></li><li><code>get()</code></li><li><code>ignore()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">ignore</span><span class="params">(<span class="keyword">int</span> =<span class="number">1</span>, <span class="keyword">int</span> = EOF)</span></span>;</span><br></pre></td></tr></table></figure><p>​默认参数<strong>EOF</strong>导致<code>ignore()</code>读取指定数目的字符或读取到文件未。</p></li></ul></li></ul><h3 id="3-文件输入和输出"><a class="markdownIt-Anchor" href="#3-文件输入和输出"></a> 3. 文件输入和输出</h3><ul><li><p>写入文件流程</p><ol><li>创建一个<code>ofstream</code>对象来管理输出流；</li><li>将该对象与特定的文件关联起来；</li><li>以使用<code>cout</code>的方式使用该对象，唯一的区别是输出将进文件而不是屏幕；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">"jar.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"jar.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">fout.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure></li><li><p>读取文件流程</p><ol><li>创建一个<code>ifstream</code>对象来管理输入流；</li><li>将对象与特定的文件关联；</li><li>以使用<code>cin</code>的方式使用该对象；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin;</span><br><span class="line">fin.<span class="built_in">open</span>(<span class="string">"jar.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"jar.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">fin.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li><li><p>检查文件是否被打开：</p><p><code>if (fin.is_open())</code></p></li><li><p><strong>文件模式</strong></p><p>文件模式描述的是文件将被如何使用：读、写、追加等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"filename"</span>, mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"filename"</span>, mode)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>文件模式常量</strong></p><ul><li><code>ios_base::in</code>：打开文件，以便读取。</li><li><code>ios_base::out</code>：打开文件，以便写入</li><li><code>os_base::ate</code>：打开文件，并移到文件尾</li><li><code>ios_base::app</code>：追加到文件尾</li><li><code>ios_base::binary</code>：二进制文件</li><li><code>ios_base::trunc</code>：如果文件存在，则截短文件(以前的内容将被删除)；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"jas.txt"</span>, ios_base::out | ios_base::app)</span></span>;</span><br><span class="line"><span class="comment">//合并模式，启用out和app模式</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="暂时写到这里其实这里的知识很多很复杂"><a class="markdownIt-Anchor" href="#暂时写到这里其实这里的知识很多很复杂"></a> 暂时写到这里，其实这里的知识很多很复杂…</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I/O（Input/Output），C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。&lt;/p&gt;
&lt;p&gt;这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。&lt;/p&gt;
&lt;p&gt;为了支持不同类型的IO处理操作，C++的IO类型
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ | 类大小问题(size of Class)</title>
    <link href="http://yoursite.com/2020/04/03/C++_%E7%B1%BB%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/03/C++_%E7%B1%BB%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-03T02:23:56.000Z</published>
    <updated>2020-04-19T06:36:20.211Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面向对象编程</strong>（OOP，Object Oriented Programming）是一种特殊的、设计程序的概念性方法。</p><p>C<ins>中的Class则是实现这一方法的重要组成部分，类是 C</ins> 的核心特性，通常被称为用户定义的类型。指定基本类型完成了三项工作：</p><ul><li>决定数据对象需要的内存数量；</li><li>决定如何解释内存中的位；</li><li>决定可使用数据对象执行的操作或方法；</li></ul><h3 id="1-class大小相关因素"><a class="markdownIt-Anchor" href="#1-class大小相关因素"></a> 1. Class大小相关因素</h3><p>类的大小与它的构造函数、析构函数以及其他成员函数无关，只与它的数据成员相关。</p><ul><li><p>有关因素</p><p><strong>普通成员变量，虚函数、继承</strong>（单一继承，多重继承，重复继承，虚拟继承）</p></li><li><p>无关因素</p><p>静态成员你变量、静态成员函数、普通成员函数</p></li></ul><h3 id="2-空类"><a class="markdownIt-Anchor" href="#2-空类"></a> 2. 空类</h3><p>空类即什么都没有的类，按上面的说法，照理说大小应该是0，但是，空类的大小为1，因为空类可以实例化，类的实例化就是为每个实例在内存中分配一块地址；每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会隐含地为其添加一个字节，以作区分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">empty_Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(empty_Class);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>继承空类的话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>:</span> <span class="keyword">public</span> empty_Class</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(base1);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>base1类的大小为4，base1类的大小是自身int成员变量的大小，至于为什么没有加上父类的大小1是因为空白基优化的问题，在空基类被继承后，子类会<strong>优化掉基类的1字节的大小</strong>，节省了空间大小，提高了运行效率。</p><h3 id="3-一般类大小"><a class="markdownIt-Anchor" href="#3-一般类大小"></a> 3. 一般类大小</h3><p>在类的定义中，因为不同类型声明顺序的不同，会导致不同的内存构造，因此类的大小会产生变化，所以应注意<strong>字节对齐</strong>，进而优化类的对象空间分布；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(baseA);<span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(baseB);<span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>baseA:</p><p style="text-align:center">    <img src="baseA.jpg" alt width="200"></p><p>baseB:</p><p style="text-align:center">    <img src="baseB.jpg" alt width="200"></p><h3 id="4-虚函数类"><a class="markdownIt-Anchor" href="#4-虚函数类"></a> 4. 虚函数类</h3><p>当一个类中包含虚函数时，会有一个指向其虚函数表的指针<strong>vptr</strong>，系统为类指针分配大小为4个字节(即使有多个虚函数)。（64位，指针大小8字节）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(virtual_A);<span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>基类Base中含有一个char型成员变量，以及两个虚函数，此时Base类的内存布局如下：</p><p><img src="20180503185905354.jpg" alt="图片加载中"></p><p>内存布局的最一开始是<strong>vfptr</strong>（virtual function ptr）即虚函数表指针（只要含虚函数，一定有虚函数表指针，而且该指针<strong>一定位于类内存模型最前端</strong>），接下来是Base类的成员变量，按照在类里的声明顺序排列，注意内存对齐原则！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(Derived);<span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>继承类Derived继承了基类，重写了Base中的虚函数f()，还添加了自己的成员变量，即int型的b，这时，Derived的类内存模型如下：</p><p><img src="20180503190906435.jpg" alt></p><h3 id="5-虚函数继承"><a class="markdownIt-Anchor" href="#5-虚函数继承"></a> 5. 虚函数继承</h3><p>32位下，<strong>vfptr</strong>（virtual function ptr）即虚函数表指针大小为4个字节</p><p>虚函数类的继承，<strong>派生类大小</strong>=派生类自身成员大小+基类数据成员大小+<strong>虚拟指针大小</strong>，（即使继承多个虚基类，也只有一个指向其虚函数表的指针vptr，大小为4字节）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(A); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">sizeof</span>(B); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;面向对象编程&lt;/strong&gt;（OOP，Object Oriented Programming）是一种特殊的、设计程序的概念性方法。&lt;/p&gt;
&lt;p&gt;C&lt;ins&gt;中的Class则是实现这一方法的重要组成部分，类是 C&lt;/ins&gt; 的核心特性，通常被称为用户定义
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2020/04/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-02T06:46:06.000Z</published>
    <updated>2020-05-16T13:03:29.111Z</updated>
    
    <content type="html"><![CDATA[<p><strong>排序</strong>（sorting）是将一组数据，按特定规则调换位置，使得数据具有某种顺序关系。</p><p>排序算法的<strong>稳定性</strong>：</p><ol><li><p>定义：能保证<strong>两个相等的数</strong>，经过排序之后，其在序列的前后位置顺序不变。（A1=A2，排序前A1在A2前面，排序后A1还在A2前面）</p></li><li><p>意义：<strong>稳定性本质是维持具有相同属性的数据的插入顺序</strong>，如果后面需要使用该插入顺序排序，则稳定性排序可以避免这次排序。</p></li></ol><p>算法分类</p><ul><li>内部排序：<ul><li>交换排序：<ul><li>冒泡排序</li><li>快速排序</li></ul></li><li>选择排序：<ul><li>简单选择排序</li><li>堆排序</li></ul></li><li>插入排序：<ul><li>直接插入排序</li><li>希尔排序</li></ul></li><li>归并排序</li><li>基数排序</li></ul></li><li>外部排序</li></ul><h3 id="1-冒泡排序"><a class="markdownIt-Anchor" href="#1-冒泡排序"></a> 1. 冒泡排序</h3><p><strong>冒泡排序</strong>（Bubble Sort）又称为<strong>交换排序</strong>法，每一次从当前最大的元素移动到列表的最右端，保证最右端的元素始终最大。这种排序算法适用于数据量小或有部分数据已经排序过，排序过程中为相邻两者互相比较和对调，并不会改变其原本排列的顺序，所以是稳定排序法。</p><p style="text-align:center">    <img src="冒泡排序.gif" alt width="50%"></p><p><strong>code:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="comment"># 遍历所有数组元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] :</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">arr = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">bubbleSort(arr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"排序后的数组:"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"%d"</span> %arr[i], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a class="markdownIt-Anchor" href="#2-选择排序"></a> 2. 选择排序</h3><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中<strong>选出</strong>最小（或最大）的一个元素，存放在序列的起始位置。</p><p style="text-align:center">    <img src="选择排序.gif" alt width="50%"></p><p><strong>code:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        min_temp = arr[i]</span><br><span class="line">        temp_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; min_temp:</span><br><span class="line">                min_temp = arr[j]</span><br><span class="line">                temp_index = j</span><br><span class="line">        arr[temp_index],arr[i] = arr[i],min_temp</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">select_sort(arr)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"排序后的数组:"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">    print(<span class="string">"%d"</span> % arr[i], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a class="markdownIt-Anchor" href="#3-插入排序"></a> 3. 插入排序</h3><p><strong>插入排序</strong>（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p style="text-align:center">    <img src="插入排序.gif" width="50%"></p><p><strong>code:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(array, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    arr = array.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(step, len(arr)):</span><br><span class="line">        <span class="keyword">while</span> i - step &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; arr[i - step]:</span><br><span class="line">                arr[i - step], arr[i] = arr[i], arr[i - step]</span><br><span class="line">                i -= step</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">sortedArr = insertionSort(arr)</span><br><span class="line">print(<span class="string">"排序后的数组:"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(sortedArr)):</span><br><span class="line">    print(<span class="string">"%d"</span> % sortedArr[i], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="4-希尔排序"><a class="markdownIt-Anchor" href="#4-希尔排序"></a> 4. 希尔排序</h3><p><strong>希尔排序</strong>（Shell Sort）是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p>该方法的基本思想是：先将整个待排元素序列分割成<strong>若干个子序列</strong>（由相隔某个“增量”的元素组成的）<strong>分别进行直接插入排序</strong>，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率比直接插入排序有较大提高。</p><p style="text-align:center">    <img src="希尔排序.gif" width="50%"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    arr = array.copy()</span><br><span class="line">    step = len(arr) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> step &gt; <span class="number">0</span>:</span><br><span class="line">        arr = insertionSort(arr, step=step)</span><br><span class="line">        step -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h3 id="5-归并排序"><a class="markdownIt-Anchor" href="#5-归并排序"></a> 5. 归并排序</h3><p><strong>归并排序（merge sort）</strong>， 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>算法描述</p><ul><li>步骤1：把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>步骤2：对这两个子序列分别采用归并排序；</li><li>步骤3：将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p style="text-align:center">    <img src="归并排序_2.gif" width="30%">    <img src="归并排序.gif" width="50%"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    arr = array.copy()</span><br><span class="line">    middleIndex = len(arr)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> middleIndex &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    leftArr, rightArr = arr[:middleIndex], arr[middleIndex:]</span><br><span class="line">    outArr = merge(mergeSort(leftArr), mergeSort(rightArr))</span><br><span class="line">    <span class="keyword">return</span> outArr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(leftArr, rightArr)</span>:</span></span><br><span class="line">    outArr = []</span><br><span class="line">    <span class="keyword">while</span> leftArr <span class="keyword">and</span> rightArr:</span><br><span class="line">        <span class="keyword">if</span> leftArr[<span class="number">0</span>] &lt;= rightArr[<span class="number">0</span>]:</span><br><span class="line">            outArr.append(leftArr.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outArr.append(rightArr.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> leftArr:</span><br><span class="line">        outArr.append(leftArr.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> rightArr:</span><br><span class="line">        outArr.append(rightArr.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> outArr</span><br></pre></td></tr></table></figure><h3 id="6-快速排序"><a class="markdownIt-Anchor" href="#6-快速排序"></a> 6. 快速排序</h3><p><strong>快速排序</strong>（quick Sort）的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p style="text-align:center">    <img src="快速排序.gif" width="50%"></p><h3 id="7-堆排序"><a class="markdownIt-Anchor" href="#7-堆排序"></a> 7. 堆排序</h3><p><strong>堆排序</strong>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：<strong>即子结点的键值或索引总是小于（或者大于）它的父节点</strong>。</p><ul><li>步骤1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>步骤2：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>步骤3：由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><p style="text-align:center">    <img src="堆排序.gif" width="50%"></p><h3 id="8-计数排序"><a class="markdownIt-Anchor" href="#8-计数排序"></a> 8. 计数排序</h3><p><strong>计数排序(Counting sort)</strong> 不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><p>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。</p><p>**基本思想：**就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。</p><p style="text-align:center">    <img src="计数排序.gif" width="50%"></p><h3 id="9-桶排序"><a class="markdownIt-Anchor" href="#9-桶排序"></a> 9. 桶排序</h3><p>桶排序就是把最大值和最小值之间的数进行瓜分，例如分成  10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。</p><p>之后每个桶里面的数据就是有序的了，我们再进行合并汇总。</p><h3 id="10-基数排序"><a class="markdownIt-Anchor" href="#10-基数排序"></a> 10. 基数排序</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p style="text-align:center">    <img src="基数排序.gif" width="50%"></p><h3 id="技术总结"><a class="markdownIt-Anchor" href="#技术总结"></a> 技术总结</h3><p style="text-align:center">    <img src="总结.png" width="80%"></p><h5 id="未完待续"><a class="markdownIt-Anchor" href="#未完待续"></a> …未完待续</h5><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><blockquote><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></p><p><a href="https://blog.csdn.net/weixin_41190227/article/details/86600821" target="_blank" rel="noopener">超详细十大经典排序算法总结（java代码）c或者cpp的也可以明白</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;（sorting）是将一组数据，按特定规则调换位置，使得数据具有某种顺序关系。&lt;/p&gt;
&lt;p&gt;排序算法的&lt;strong&gt;稳定性&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义：能保证&lt;strong&gt;两个相等的数&lt;/stron
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>python | python笔记</title>
    <link href="http://yoursite.com/2020/04/01/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/01/python%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-01T12:36:12.000Z</published>
    <updated>2020-04-03T02:27:01.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-eval"><a class="markdownIt-Anchor" href="#1-eval"></a> 1. eval</h3><p>eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。即变量赋值时，等号右边的表示是写成字符串的格式，返回值就是这个表达式的结果。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><ul><li>expression – 表达式。</li><li>globals – 变量作用域，全局命名空间，如果被提供，则必须是<strong>一个字典对象</strong>。</li><li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul><ol><li><p>简单表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(eval(<span class="string">'1 + 2'</span>))<span class="comment"># 3</span></span><br><span class="line">print(eval(<span class="string">'(1 + 2) * 3'</span>))<span class="comment"># 9</span></span><br></pre></td></tr></table></figure></li><li><p>传递全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(eval(<span class="string">"&#123;'name':'linux','age':age&#125;"</span>,&#123;<span class="string">"age"</span>:<span class="number">1822</span>&#125;))</span><br><span class="line"><span class="comment"># &#123;'name': 'linux', 'age': 1822&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>传递本地变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age=<span class="number">18</span></span><br><span class="line">print(eval(<span class="string">"&#123;'name':'linux','age':age&#125;"</span>,&#123;<span class="string">"age"</span>:<span class="number">1822</span>&#125;,locals()))</span><br><span class="line"><span class="comment"># &#123;'name':'linux','age':18&#125;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-eval&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-eval&quot;&gt;&lt;/a&gt; 1. eval&lt;/h3&gt;
&lt;p&gt;eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。即变量赋值时，等号右边的表示是写
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python | python命名空间和作用域</title>
    <link href="http://yoursite.com/2020/04/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/04/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-04-01T12:00:10.000Z</published>
    <updated>2020-04-03T02:27:23.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-命名空间"><a class="markdownIt-Anchor" href="#1-命名空间"></a> 1. 命名空间</h3><p>命名空间(namespace)一词，时常出现在C/C++程序开发中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>所谓namespace，是指标识符的各种可见范围。C++标准程序库中的所有标识符都被定义于一个名为<strong>std</strong>的namespace中。我们一般用命名空间来区分同名的不同变量或函数。</p><p>在python的学习中，无意间命名空间的概念在一定程度上被弱化。实际上，在python同样存在着命名空间的概念，命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p><p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p><p>python中一般有三种命名空间：</p><ul><li><strong>内置名称（built-in names）</strong>， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</li></ul><p>python中命名空间查找顺序：<strong>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p><p>python的全局名字空间存储在一个叫**globals()<strong>的dict对象中；局部名字空间存储在一个叫</strong>locals()**的dict对象中。可以用print (locals())来查看该函数体内的所有变量名和变量值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"局部作用域下："</span>)</span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line">print(<span class="string">"全局作用域下："</span>)</span><br><span class="line">print(globals())</span><br><span class="line">print(locals())</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">全局作用域下：</span><br><span class="line">&#123;...（省略很多信息）, 'n': 1, 'test': &lt;function test at 0x00000182E55E3E18&gt;&#125;</span><br><span class="line">&#123;...（省略很多信息）, 'n': 1, 'test': &lt;function test at 0x00000182E55E3E18&gt;&#125;</span><br><span class="line">局部作用域下：</span><br><span class="line">&#123;'n': 2&#125;</span><br></pre></td></tr></table></figure><p>命名空间的生命周期：</p><p>命名空间的生命周期取决于对象的<strong>作用域</strong>，如果对象执行完成，则该命名空间的生命周期就结束。因此，我们无法从外部命名空间访问内部命名空间的对象。</p><h3 id="2-作用域"><a class="markdownIt-Anchor" href="#2-作用域"></a> 2. 作用域</h3><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python作用域一共4种，分别是：</p><ul><li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数/方法内部。</li><li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类）A里面又包含了一个函数B，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li><li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li><li><strong>B（Built-in）</strong>：包含了内建的变量/关键字等，最后被搜索。</li></ul><p>查找顺序： <strong>L –&gt; E –&gt; G –&gt; B</strong></p><p>python引入新的作用域：</p><p><strong>只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域</strong>，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line">print(i)</span><br><span class="line"><span class="comment">#以下为输出结果</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>而在C/C++中，代码块中的局部变量会随着代码块的运行结束而释放，不能访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i;   <span class="comment">// 出错：'i' was not declared in this scope</span></span><br></pre></td></tr></table></figure><p>当内部作用域想修改外部作用域的变量时，就要用到<strong>global</strong>和<strong>nonlocal</strong>关键字了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num<span class="comment">#global声明num变量为全局变量</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">print(num)<span class="comment"># 1  </span></span><br><span class="line">change_num()</span><br><span class="line">print(num)<span class="comment"># 100</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_num</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        num = <span class="number">10</span><span class="comment"># 仅改变了enclosing作用域，外层非全局作用域</span></span><br><span class="line">    print(num)<span class="comment"># 100</span></span><br><span class="line">    inner()</span><br><span class="line">    print(num)<span class="comment"># 10</span></span><br><span class="line">change_num()</span><br><span class="line">print(num) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-命名空间&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-命名空间&quot;&gt;&lt;/a&gt; 1. 命名空间&lt;/h3&gt;
&lt;p&gt;命名空间(namespace)一词，时常出现在C/C++程序开发中。&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-03-31T06:11:07.000Z</published>
    <updated>2020-03-31T08:24:35.004Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有<strong>重复子问题</strong>和<strong>最优子结构</strong>的问题。</p><ul><li><p>如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就具备<strong>最优子结构</strong></p></li><li><p>如果计算最优解时需要处理很多相同的问题，那么这个问题就具备<strong>重复子问题</strong></p></li></ul><p>当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个<strong>memory</strong>来缓存重复子问题的结果，<strong>避免了递归的过程中的大量的重复计算</strong>。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的。</p><p>当要应用动态规划来解决问题时，归根结底就是想办法完成以下三个关键目标。</p><ol><li>建立状态转移方程</li></ol><p>这一步通常是最难的…，状态之间的关系。例如<strong>斐波那契数列</strong>，状态转移方程为：<code>f(n)=f(n-1)+f(n-2)</code></p><ol start="2"><li><p>缓存把那个复用以往结果</p></li><li><p>按顺序从小往大算</p></li></ol><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例：</h3><p>看看最简单的斐波那契数列：0,1,1,2,3 … 从第0项开始，<code>f(n) = f(n-1)+f(n-2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统的递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划形式#1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_1</span><span class="params">(n)</span>:</span></span><br><span class="line">    memory = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        memory.append(memory[i - <span class="number">1</span>] + memory[i - <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划#2递归形式</span></span><br><span class="line">memory = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">if</span> n &gt;= len(memory):</span><br><span class="line">        memory.append(fibo_dp_2(n - <span class="number">1</span>) + fibo_dp_2(n - <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br></pre></td></tr></table></figure><p>当计算的数较小时：三种方式花费时间差距并不大：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span>, res = <span class="number">55</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">0.000063</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000011</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000014</span>sec</span><br></pre></td></tr></table></figure><p>当计算的数较大时，耗时差距就体现出来，动态规划<strong>缓存</strong>的重要性便凸显出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">37</span>, res = <span class="number">24157817</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">16.511701</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000026</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000044</span>sec</span><br></pre></td></tr></table></figure><p>动态规划速度的快，是因为它将之前的小问题的结果保存在缓存中，而传统的递归方式，相当于重复计算小问题，因此耗时。</p><p><img src="%E4%BC%A0%E7%BB%9F%E9%80%92%E5%BD%92.jpg" alt="image-20200331161524036"></p><p>当然这只是动态规划的最简单形式，动态规划的Leetcode专栏：</p><p><a href="https://leetcode-cn.com/tag/dynamic-programming/" target="_blank" rel="noopener">leetcode/动态规划</a></p><p>唉…我太菜了，很多时候找不到状态转移关系…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有&lt;strong&gt;重复子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>A-star算法</title>
    <link href="http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T05:09:56.000Z</published>
    <updated>2020-04-19T06:48:38.690Z</updated>
    
    <content type="html"><![CDATA[<p>A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。</p><blockquote><p>本文动图、内容来源：<a href="https://www.jianshu.com/u/12532d36e4da" target="_blank" rel="noopener">阿里云云栖号</a></p></blockquote><h3 id="路径规划的一些算法"><a class="markdownIt-Anchor" href="#路径规划的一些算法"></a> 路径规划的一些算法</h3><ol><li>广度优先搜索算法</li></ol><p>BFS（Breadth first search）从起点开始，首先遍历起点周围临近点，然后在遍历已经遍历过的点未访问过的临近点，逐步向外扩散，直到找到终点。BFS以广度为优先级进行搜索。</p><p style="text-align:center">    <img src="BFS" width="50%"></p><ol start="2"><li>dijkstra算法</li></ol><p>Dijkstra算法用来寻找图形中节点之间的最短路径。Dijkstra算法可以视作BFS算法的带权版本，增加了路径代价的概念。算法执行过程中，每次都从优先级队列中选出代价最小的作为下一个点，直到到达终点。</p><p style="text-align:center">    <img src="dijkstra" width="50%"></p><ol start="3"><li>最佳优先搜索</li></ol><p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p><p>与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p><p style="text-align:center">    <img src="bestfs_good" width="50%"></p><p>但是这样也会出现不良情况，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</p><p style="text-align:center">    <img src="bestfs_bad" width="50%"></p><h3 id="a算法"><a class="markdownIt-Anchor" href="#a算法"></a> A*算法</h3><p>A*算法实际上是综合上面这些算法的特点于一身的。</p><p>A*算法通过下面这个函数来计算每个节点的优先级。</p><p><code>f(n)=g(n)+h(n)</code></p><p>在上式中：</p><ul><li><code>f(n)</code>为节点n的综合优先级；</li><li><code>g(n)</code>为节点n距离起点的代价；</li><li><code>h(n)</code>为节点n距离终点的预计代价。</li></ul><p>上式即为A*算法的启发函数。A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。</p><p>另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为<code>open_set</code>和<code>close_set</code>。完整的A*算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 初始化open_set和close_set；</span><br><span class="line">* 将起点加入open_set中，并设置优先级为0（优先级最高）；</span><br><span class="line">* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span><br><span class="line">    * 如果节点n为终点，则：</span><br><span class="line">        * 从终点开始逐步追踪parent节点，一直达到起点；</span><br><span class="line">        * 返回找到的结果路径，算法结束；</span><br><span class="line">    * 如果节点n不是终点，则：</span><br><span class="line">        * 将节点n从open_set中删除，并加入close_set中；</span><br><span class="line">        * 遍历节点n所有的邻近节点：</span><br><span class="line">            * 如果邻近节点m在close_set中，则：</span><br><span class="line">                * 跳过，选取下一个邻近节点</span><br><span class="line">            * 如果邻近节点m也不在open_set中，则：</span><br><span class="line">                * 设置节点m的parent为节点n</span><br><span class="line">                * 计算节点m的优先级</span><br><span class="line">                * 将节点m加入open_set中</span><br></pre></td></tr></table></figure><p>上面已经提到，启发函数会影响A*算法的行为。</p><ul><li>在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时<strong>算法就退化成了Dijkstra算法</strong>。</li><li>如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。</li><li>如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li><li>如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li><li>在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。</li></ul><p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p><p>对于网格形式的图，有以下这些启发函数可以使用：</p><ul><li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。<code>C</code>为移动代价</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> C * (dx+dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝八个方向移动，则可以使用对角距离。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> D * (dx + dy) + (D2 - <span class="number">2</span> * D) * min(dx, dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</li></ul><h3 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性：</h3><p>虽然 Ａ ＊ 算法能有效解决最短路径问题，但其存在易陷入“死循环”、规划路径折点多、在动态环境中规划效果不佳等问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。&lt;/p&gt;
&lt;blo
      
    
    </summary>
    
    
    
      <category term="A*" scheme="http://yoursite.com/tags/A/"/>
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T01:11:56.000Z</published>
    <updated>2020-04-19T06:48:48.514Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中<strong>不存在负权边</strong>。用于求图中指定两点之间的<strong>最短路径</strong>，或者是<strong>指定一点到其它</strong>所有点之间的最短路径。实质上是<strong>贪心算法</strong>。</p><p>Dijkstra算法可以说是BFS（宽度优先搜索算法）的升级版，BFS的实现可以依靠队列实现，而Dijkstra算法可以通过优先级队列进行实现。</p><p style="text-align:center">    <img src="2012073019540660.gif" width="30%"></p><h3 id="1-算法描述"><a class="markdownIt-Anchor" href="#1-算法描述"></a> 1. 算法描述</h3><p><strong>Dijkstra算法</strong>利用贪心策略，从起始点开始出发，选择距离当前位置最近的点加入路径。</p><p>因此算法用到两个集合：</p><ol><li>当前路径中已有点的集合</li><li>当前路径中未包含点的集合</li></ol><p>**原理：**Dijkstra的大致思想就是，根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合，集合中所有的点的d[i]都是该点到初始点最短路径长度，由于后加入的点是根据集合S中的点为基础拓展的，所以也能找到最短路径。</p><p>1.将图上的初始点看作一个集合S，其它点看作另一个集合</p><p>2.根据初始点，求出其它点到初始点的距离d[i] （若相邻，则d[i]为边权值；若不相邻，则d[i]为无限大）</p><p>3.选取最小的d[i]（记为d[x]），并将此d[i]边对应的点（记为x）加入集合S</p><p>4.再根据x，更新跟 x 相邻点 y 的d[y]值：d[y] = min{ d[y], d[x] + 边权值w[x][y] }，因为可能把距离调小，所以这个更新操作叫做<strong>松弛操作</strong>。</p><p>5.重复3，4两步，直到目标点也加入了集合，此时目标点所对应的d[i]即为最短路径长度。</p><p>较好理解的视频：（用优先级队列实现）</p><p><a href="https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中&lt;strong&gt;不存在负权边&lt;/strong&gt;。
      
    
    </summary>
    
    
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zilch个人博客</title>
  
  <subtitle>博客,Hexo,车辆工程,Linux</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-31T08:24:35.004Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zilch</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-03-31T06:11:07.000Z</published>
    <updated>2020-03-31T08:24:35.004Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有<strong>重复子问题</strong>和<strong>最优子结构</strong>的问题。</p><ul><li><p>如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就具备<strong>最优子结构</strong></p></li><li><p>如果计算最优解时需要处理很多相同的问题，那么这个问题就具备<strong>重复子问题</strong></p></li></ul><p>当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个<strong>memory</strong>来缓存重复子问题的结果，<strong>避免了递归的过程中的大量的重复计算</strong>。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的。</p><p>当要应用动态规划来解决问题时，归根结底就是想办法完成以下三个关键目标。</p><ol><li>建立状态转移方程</li></ol><p>这一步通常是最难的…，状态之间的关系。例如<strong>斐波那契数列</strong>，状态转移方程为：<code>f(n)=f(n-1)+f(n-2)</code></p><ol start="2"><li><p>缓存把那个复用以往结果</p></li><li><p>按顺序从小往大算</p></li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>看看最简单的斐波那契数列：0,1,1,2,3 …… 从第0项开始，<code>f(n) = f(n-1)+f(n-2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统的递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划形式#1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_1</span><span class="params">(n)</span>:</span></span><br><span class="line">    memory = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        memory.append(memory[i - <span class="number">1</span>] + memory[i - <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划#2递归形式</span></span><br><span class="line">memory = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">if</span> n &gt;= len(memory):</span><br><span class="line">        memory.append(fibo_dp_2(n - <span class="number">1</span>) + fibo_dp_2(n - <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br></pre></td></tr></table></figure><p>当计算的数较小时：三种方式花费时间差距并不大：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span>, res = <span class="number">55</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">0.000063</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000011</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000014</span>sec</span><br></pre></td></tr></table></figure><p>当计算的数较大时，耗时差距就体现出来，动态规划<strong>缓存</strong>的重要性便凸显出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">37</span>, res = <span class="number">24157817</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">16.511701</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000026</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000044</span>sec</span><br></pre></td></tr></table></figure><p>动态规划速度的快，是因为它将之前的小问题的结果保存在缓存中，而传统的递归方式，相当于重复计算小问题，因此耗时。</p><p><img src="%E4%BC%A0%E7%BB%9F%E9%80%92%E5%BD%92.jpg" alt="image-20200331161524036"></p><p>当然这只是动态规划的最简单形式，动态规划的Leetcode专栏：</p><p><a href="https://leetcode-cn.com/tag/dynamic-programming/" target="_blank" rel="noopener">leetcode/动态规划</a></p><p>唉….我太菜了，很多时候找不到状态转移关系…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有&lt;strong&gt;重复子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就具
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>A-star算法</title>
    <link href="http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T05:09:56.000Z</published>
    <updated>2020-03-30T08:01:28.574Z</updated>
    
    <content type="html"><![CDATA[<p>A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。</p><blockquote><p>本文动图、内容来源：<a href="https://www.jianshu.com/u/12532d36e4da" target="_blank" rel="noopener">阿里云云栖号</a></p></blockquote><h3 id="路径规划的一些算法"><a href="#路径规划的一些算法" class="headerlink" title="路径规划的一些算法"></a>路径规划的一些算法</h3><ol><li>广度优先搜索算法</li></ol><p>BFS（Breadth first search）从起点开始，首先遍历起点周围临近点，然后在遍历已经遍历过的点未访问过的临近点，逐步向外扩散，直到找到终点。BFS以广度为优先级进行搜索。</p><p><img src="BFS" alt="图片加载中"></p><ol start="2"><li>dijkstra算法</li></ol><p>Dijkstra算法用来寻找图形中节点之间的最短路径。Dijkstra算法可以视作BFS算法的带权版本，增加了路径代价的概念。算法执行过程中，每次都从优先级队列中选出代价最小的作为下一个点，直到到达终点。</p><p><img src="dijkstra" alt></p><ol start="3"><li>最佳优先搜索</li></ol><p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p><p>与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p><p><img src="bestfs_good" alt></p><p>但是这样也会出现不良情况，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</p><p><img src="bestfs_bad" alt></p><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>A*算法实际上是综合上面这些算法的特点于一身的。</p><p>A*算法通过下面这个函数来计算每个节点的优先级。</p><p><code>f(n)=g(n)+h(n)</code></p><p>在上式中：</p><ul><li><code>f(n)</code>为节点n的综合优先级；</li><li><code>g(n)</code>为节点n距离起点的代价；</li><li><code>h(n)</code>为节点n距离终点的预计代价。</li></ul><p>上式即为A*算法的启发函数。A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。</p><p>另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为<code>open_set</code>和<code>close_set</code>。完整的A*算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 初始化open_set和close_set；</span><br><span class="line">* 将起点加入open_set中，并设置优先级为0（优先级最高）；</span><br><span class="line">* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span><br><span class="line">    * 如果节点n为终点，则：</span><br><span class="line">        * 从终点开始逐步追踪parent节点，一直达到起点；</span><br><span class="line">        * 返回找到的结果路径，算法结束；</span><br><span class="line">    * 如果节点n不是终点，则：</span><br><span class="line">        * 将节点n从open_set中删除，并加入close_set中；</span><br><span class="line">        * 遍历节点n所有的邻近节点：</span><br><span class="line">            * 如果邻近节点m在close_set中，则：</span><br><span class="line">                * 跳过，选取下一个邻近节点</span><br><span class="line">            * 如果邻近节点m也不在open_set中，则：</span><br><span class="line">                * 设置节点m的parent为节点n</span><br><span class="line">                * 计算节点m的优先级</span><br><span class="line">                * 将节点m加入open_set中</span><br></pre></td></tr></table></figure><p>上面已经提到，启发函数会影响A*算法的行为。</p><ul><li>在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时<strong>算法就退化成了Dijkstra算法</strong>。</li><li>如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。</li><li>如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li><li>如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li><li>在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。</li></ul><p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p><p>对于网格形式的图，有以下这些启发函数可以使用：</p><ul><li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。<code>C</code>为移动代价</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> C * (dx+dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝八个方向移动，则可以使用对角距离。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> D * (dx + dy) + (D2 - <span class="number">2</span> * D) * min(dx, dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</li></ul><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h3><p>虽然 Ａ ＊ 算法能有效解决最短路径问题，但其存在易陷入“死循环”、规划路径折点多、在动态环境中规划效果不佳等问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。&lt;/p&gt;
&lt;blo
      
    
    </summary>
    
    
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*" scheme="http://yoursite.com/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T01:11:56.000Z</published>
    <updated>2020-03-30T05:15:39.621Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中<strong>不存在负权边</strong>。用于求图中指定两点之间的<strong>最短路径</strong>，或者是<strong>指定一点到其它</strong>所有点之间的最短路径。实质上是<strong>贪心算法</strong>。</p><p>Dijkstra算法可以说是BFS（宽度优先搜索算法）的升级版，BFS的实现可以依靠队列实现，而Dijkstra算法可以通过优先级队列进行实现。</p><p><img src="2012073019540660.gif" alt="图片加载中"></p><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1. 算法描述"></a>1. 算法描述</h3><p><strong>Dijkstra算法</strong>利用贪心策略，从起始点开始出发，选择距离当前位置最近的点加入路径。</p><p>因此算法用到两个集合：</p><ol><li>当前路径中已有点的集合</li><li>当前路径中未包含点的集合</li></ol><p><strong>原理：</strong>Dijkstra的大致思想就是，根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合，集合中所有的点的d[i]都是该点到初始点最短路径长度，由于后加入的点是根据集合S中的点为基础拓展的，所以也能找到最短路径。</p><p>1.将图上的初始点看作一个集合S，其它点看作另一个集合</p><p>2.根据初始点，求出其它点到初始点的距离d[i] （若相邻，则d[i]为边权值；若不相邻，则d[i]为无限大）</p><p>3.选取最小的d[i]（记为d[x]），并将此d[i]边对应的点（记为x）加入集合S</p><p>4.再根据x，更新跟 x 相邻点 y 的d[y]值：d[y] = min{ d[y], d[x] + 边权值w[x][y] }，因为可能把距离调小，所以这个更新操作叫做<strong>松弛操作</strong>。</p><p>5.重复3，4两步，直到目标点也加入了集合，此时目标点所对应的d[i]即为最短路径长度。</p><p>较好理解的视频：（用优先级队列实现）</p><p><a href="https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中&lt;strong&gt;不存在负权边&lt;/strong&gt;。
      
    
    </summary>
    
    
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试图片</title>
    <link href="http://yoursite.com/2020/03/29/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2020/03/29/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</id>
    <published>2020-03-29T11:27:06.000Z</published>
    <updated>2020-03-29T14:16:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片</p><p><img src="zentree_1.png" alt="zentree_1"><br><img src="zentree_1.png" alt="zentree_1"></p><p><img src="test.jpg" alt="zentree_1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上
      
    
    </summary>
    
    
    
      <category term="测试图片" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="http://yoursite.com/2020/03/29/hello/"/>
    <id>http://yoursite.com/2020/03/29/hello/</id>
    <published>2020-03-29T10:49:59.000Z</published>
    <updated>2020-03-29T10:51:30.203Z</updated>
    
    <content type="html"><![CDATA[<p>今天成功利用hexo构建个人博客，由GitHub page进行托管</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天成功利用hexo构建个人博客，由GitHub page进行托管&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="启程" scheme="http://yoursite.com/tags/%E5%90%AF%E7%A8%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zilch个人博客</title>
  
  <subtitle>博客,Hexo,车辆工程,Linux</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-08T11:03:09.256Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zilch</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMAKE | Cmake与开发</title>
    <link href="http://yoursite.com/2020/04/08/%E6%B5%85%E8%B0%88Cmake/"/>
    <id>http://yoursite.com/2020/04/08/%E6%B5%85%E8%B0%88Cmake/</id>
    <published>2020-04-08T06:42:14.000Z</published>
    <updated>2020-04-08T11:03:09.256Z</updated>
    
    <content type="html"><![CDATA[<p>CMake是个一个开源的跨平台<strong>自动化建构</strong>系统，用来管理软件建置的程序，并不相依于某特定编译器。可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的Makefile或者project文件，CMake 并不直接建构出最终的软件，而是产生标准的建构档（如Unix的Makefile或projects），然后再依一般的建构方式使用。</p><h3 id="1-基本模板"><a class="markdownIt-Anchor" href="#1-基本模板"></a> 1. 基本模板</h3><p>Cmake的基础便是<strong>CMakeLists.txt</strong>文件，一般：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment"># 资源目录</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE DIR: "</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置源文件变量, 并添加文件（多个）</span></span><br><span class="line"><span class="comment"># set(src_list xxx.cpp xxx.cpp xx.cpp)</span></span><br><span class="line"><span class="keyword">set</span>(src_list main.cpp <span class="number">1</span>.cpp)</span><br><span class="line"><span class="comment"># 目标可执行文件</span></span><br><span class="line"><span class="comment"># 可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(target_file <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印提示信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE: "</span> <span class="variable">$&#123;src_list&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"TARGET: "</span> <span class="variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/<span class="variable">$&#123;target_file&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"-Wall -std=c++11"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定头文件目录位置</span></span><br><span class="line"><span class="comment"># INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/include)</span></span><br><span class="line"><span class="comment">#添加共享库搜索路径</span></span><br><span class="line"><span class="comment"># LINK_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置头文件位置，相当于g++ -I，可以用相对或绝对路径，也可以用自定义的变量值</span></span><br><span class="line"><span class="comment"># include_directories($&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用给定的源文件，为工程引入一个可执行文件test。</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;target_file&#125;</span> <span class="variable">$&#123;src_list&#125;</span>)</span><br></pre></td></tr></table></figure><p>编译的时候，当源文件很多的时候，可以使用 <code>aux_source_directory</code> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;target_file&#125;</span> <span class="variable">$&#123;src_list&#125;</span>)</span><br></pre></td></tr></table></figure><p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 CMakeDemo的可执行文件。</p><h3 id="2-生成库文件"><a class="markdownIt-Anchor" href="#2-生成库文件"></a> 2. 生成库文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;name&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br></pre></td></tr></table></figure><p><strong>库文件</strong>是事先编译好的方法的合集。比如：我们提前写好一些数据公式的实现，将其打包成库文件，以后使用只需要库文件就可以，不需要重新编写。</p><p>库文件分两种：静态库和动态库（也叫共享库）</p><ul><li>Windows系统静态库扩展名为：.lib，动态库扩展名为.dll；</li><li>Linux系统下静态库的扩展名为.a，<a href="http://xn--siqu1iv4aj0s8zczwcivgp04c.so" target="_blank" rel="noopener">动态库的扩展名为.so</a>；</li></ul><ol><li><strong>Cmake生成静态库</strong></li></ol><p>静态库（也称作归档文件），程序在链接的过程中，链接器从库文件中取得所需代码，复制到生成的可执行文件中。因此，<strong>静态库是在程序员的链接阶段被复制到程序当中</strong>，和程序的执行没有任何关系。</p><p>这类库在编译的时候会<strong>直接整合到目标程序中</strong>，所以利用静态函数库编译成的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE: "</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是关键，生成静态库（默认）</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Cmake生成动态库</strong></li></ol><p>与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序里只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SOURCE: "</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是关键，生成动态库！SHARED</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-链接库"><a class="markdownIt-Anchor" href="#3-链接库"></a> 3. 链接库</h3><ul><li><strong>link_directories</strong></li></ul><p>该指令的作用主要是指定要链接的库文件的<strong>路径</strong>，该指令有时候<strong>不一定需要</strong>。因为find_package和find_library指令可以得到库文件的绝对路径。不过你自己写的动态库文件放在自己新建的目录下时，可以用该指令指定该目录的路径以便工程能够找到。</p><ul><li><strong>target_link_libraries</strong></li></ul><p>该指令的作用为将目标文件与库文件进行链接。该指令的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; [item1] [item2] [...]</span><br><span class="line">                      [[debug|optimized|general] &lt;item&gt;] ...)</span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><p>假设我们需要寻找当前目录中lib/libmath.so，则CMakeLIsts.txt:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加库目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库libmath.so or libmath.a</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="keyword">math</span>)</span><br></pre></td></tr></table></figure><h3 id="4-外部项目"><a class="markdownIt-Anchor" href="#4-外部项目"></a> 4. 外部项目</h3><p>当当前编译的项目需要外部文件支持时，可以将外部文件编译为静态链接库，然后链接到目标，</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加外部文件夹，并执行该文件夹下方的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(sub1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加静态库，sub-&gt;实际中：libsub.a</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target_file&#125;</span> sub)</span><br></pre></td></tr></table></figure><p>同时，外部文件夹sub1中，同样需要CMakeLIsts.txt文件：例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 当前工程名称</span></span><br><span class="line"><span class="keyword">project</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> DIR_SRCS)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="cmake-clean"><a class="markdownIt-Anchor" href="#cmake-clean"></a> cmake clean</h3><p>cmake没有提供类似Makefile中clean的命令，因此可以在源文件同级目录下写一个Makefile，内容如下：<a href="https://blog.csdn.net/coldplayplay/article/details/78508883?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">CSDN-coldplayplay</a></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BUILD_DIR = ./build</span><br><span class="line">DEST_DIR = ./bin</span><br><span class="line">DEST_EXE_NAME = main</span><br><span class="line"></span><br><span class="line"><span class="section">all: build</span></span><br><span class="line">    cd <span class="variable">$(BUILD_DIR)</span>;  make -j4</span><br><span class="line"><span class="section">run:</span></span><br><span class="line">    cd <span class="variable">$(DEST_DIR)</span>; ./<span class="variable">$(DEST_EXE_NAME)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm <span class="variable">$(BUILD_DIR)</span> -rf</span><br><span class="line"><span class="section">build:</span></span><br><span class="line">    mkdir <span class="variable">$(BUILD_DIR)</span>;cd <span class="variable">$(BUILD_DIR)</span>; cmake ..</span><br></pre></td></tr></table></figure><h3 id="cmake基础部分大概如此更加进阶的基于基础在实战中进步"><a class="markdownIt-Anchor" href="#cmake基础部分大概如此更加进阶的基于基础在实战中进步"></a> cmake基础部分大概如此，更加进阶的基于基础在实战中进步！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CMake是个一个开源的跨平台&lt;strong&gt;自动化建构&lt;/strong&gt;系统，用来管理软件建置的程序，并不相依于某特定编译器。可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的Makefile或者project文件，CMake 并不直接建构出最终的软件
      
    
    </summary>
    
    
    
      <category term="Cmake" scheme="http://yoursite.com/tags/Cmake/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>python | 浅谈Python类</title>
    <link href="http://yoursite.com/2020/04/07/python%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/04/07/python%E7%B1%BB/</id>
    <published>2020-04-07T07:07:18.000Z</published>
    <updated>2020-04-07T08:52:14.838Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/hezl1592/Daily-Python/blob/master/Class/class_1.py" target="_blank" rel="noopener">GitHub代码示例</a></li></ul><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。</p><p>相关名词：</p><ul><li><strong>类（class）</strong>：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法</strong>：类中定义的函数。</li><li><strong>类变量</strong>：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员</strong>：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>局部变量</strong>：定义在方法中的变量，只作用于当前实例的类；</li><li>**实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。</li><li>**实例化：**创建一个类的实例，类的具体对象。</li><li>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h3 id="1-类的定义"><a class="markdownIt-Anchor" href="#1-类的定义"></a> 1. 类的定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    <span class="comment"># .</span></span><br><span class="line">    <span class="comment"># .</span></span><br><span class="line">    &lt;statement-N&gt;</span><br><span class="line">obj = Classname()<span class="comment">#实例化得到对象</span></span><br></pre></td></tr></table></figure><p>类<strong>实例化后</strong>，才可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p><p><strong>类的权限控制</strong></p><ul><li><p>私有属性：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。</p><ul><li>类变量：<code>__privateattrs</code></li><li>实例变量：<code>self.__privateattrs</code></li></ul></li><li><p>私有方法：</p><p><code>__privatemethod</code>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。</p></li></ul><h3 id="2-类对象"><a class="markdownIt-Anchor" href="#2-类对象"></a> 2. 类对象</h3><p>类有一个名为<code>__init__</code>的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用，也就是构造函数。参数通过<code>__init__</code>传递到类的实例化操作上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x1, x2)</span>:</span></span><br><span class="line">        self.x1 = x1</span><br><span class="line">        self.x2 = x2</span><br><span class="line">x = classname(x1,x2)<span class="comment">#实例化为对象</span></span><br></pre></td></tr></table></figure><p>在这里，需要注意的是，<code>self</code>代表类的实例，而非类本身。同时<code>self</code>不是python的关键字，换成其他名称也可以。</p><h3 id="3-类的方法"><a class="markdownIt-Anchor" href="#3-类的方法"></a> 3. 类的方法</h3><p>在类的内部，使用<code>def</code>关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self, 且为第一个参数，self 代表的是类的实例。</strong></p><p><strong>类的专有方法：</strong></p><ul><li><code>__init__</code>：构造函数，在生成对象时调用</li><li><code>__del__</code>：析构函数，释放对象时使用</li><li><code>__repr__</code>：打印，转换。<code>__str__</code>实际上调用了该方法</li><li><code>__setitem__</code>：按照索引赋值</li><li><code>__getitem__</code>：按照索引获取值</li><li><code>__len__</code>：获得长度</li><li><code>__cmp__</code>：比较运算</li><li><code>__call__</code>：函数调用</li><li><code>__add__</code>：加运算</li><li><code>__sub__</code>：减运算</li><li><code>__mul__</code>：乘运算</li><li><code>__truediv__</code>：除运算</li><li><code>__mod__</code>：求余运算</li><li><code>__pow__</code>：乘方</li></ul><p>以上所有的专用方法都可以继承后重写~，我们可以对类的专有方法进行重载</p><h3 id="4-继承"><a class="markdownIt-Anchor" href="#4-继承"></a> 4. 继承</h3><p><strong>Python</strong>同样支持类的继承，派生类的定义如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName1)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(modname.BaseClassName)</span>:</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    __num = <span class="number">0</span><span class="comment">#私有类属性，记录创建对象数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        People.__num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'编号:&#123;&#125;,\t姓名:&#123;&#125;,\t性别:&#123;&#125;'</span>.format(People.__num, self.name, self.gender)</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(People)</span>:</span></span><br><span class="line">    __num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, grade)</span>:</span></span><br><span class="line">        super().__init__(name, gender)</span><br><span class="line">        self.grade = grade</span><br><span class="line">        Student.__num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__str__() + <span class="string">",\t在读&#123;&#125;年级, 学生编号:&#123;&#125;."</span>.format(self.grade, Student.__num)</span><br></pre></td></tr></table></figure><h3 id="5-多继承"><a class="markdownIt-Anchor" href="#5-多继承"></a> 5. 多继承</h3><p>Python同样支持多继承形式。多继承的类定义形如下例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>需要注意圆括号中<strong>父类的顺序</strong>，若是父类中有相同的方法名，而在子类使用时未指定，python从<strong>左至右搜索</strong>即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><p>Python 提供super用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p><p>C++中使用虚拟继承来解决重复调用问题；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hezl1592/Daily-Python/blob/master/Class/class_1.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub代码示例&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
    
    
      <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>C++ | IO标准库&amp;文件操作</title>
    <link href="http://yoursite.com/2020/04/05/C++_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/04/05/C++_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6/</id>
    <published>2020-04-05T07:43:33.000Z</published>
    <updated>2020-04-06T05:13:17.724Z</updated>
    
    <content type="html"><![CDATA[<p>I/O（Input/Output），C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。</p><p>这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。</p><p>为了支持不同类型的IO处理操作，C++的IO类型定义在三个独立的头文件中：（w:宽字符）</p><ul><li>iostream定义了用于读写流的基本类型；<ul><li>istream，wistream从流读取数据</li><li>ostream, wostream向流写入数据</li><li>iostream，wiostream读写流</li></ul></li><li>fstream定义了读写命名文件的类型；<ul><li>ifstream, wifstream从文件读取数据</li><li>ofstream, wofstream项文件写入数据</li><li>fstream,wfstream读写文件</li></ul></li><li>sstream定义了读写内存string对象的类型。<ul><li>istringstream,wistringstream从string读取数据</li><li>ostringstream，wostringstream向string写入数据</li><li>stringstream，wstringstream读写string</li></ul></li></ul><p><strong>常见IO对象</strong>：</p><ul><li><p><code>cin</code>，一个istream对象，从标准输入读取数据。</p></li><li><p><code>cout</code>，一个ostream对象，从标准输出写入数据。</p></li><li><p><code>cerr</code>，一个ostream对象，用于输出错误消息。</p></li><li><p><code>getline</code>函数，从一个给定的输入流读取一行数据存入string对象。</p></li></ul><h3 id="1-使用cout进行输出"><a class="markdownIt-Anchor" href="#1-使用cout进行输出"></a> 1. 使用cout进行输出</h3><p><code>&lt;&lt;</code>运算符的默认含义是按位左移运算符，ostream类将<code>&lt;&lt;</code>重载为输出，在这种情况下，<code>&lt;&lt;</code>被称为插入运算符，能都识别C++中<strong>所有的基本类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">88</span>;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><ul><li><p>输出与指针</p><p>ostream类为下面的指针类型定义了插入运算符函数：</p><ul><li>const signed char *;</li><li>const unsigned char *;</li><li>const char *;</li><li>void *;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> eggs = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">char</span> *amount = <span class="string">"dozen"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;eggs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; amount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span> *)amount &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//字符串的地址</span></span><br></pre></td></tr></table></figure></li><li><p>拼接输出</p><p>插入运算符的返回类型都是ostream &amp;。</p><p>因此:<code>cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl;</code></p></li><li><p>其他ostream方法</p><p>ostream类还提供了<code>put()</code>和<code>write()</code>方法，前者用于显示<strong>字符</strong>，后者用于显示<strong>字符串</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'W'</span>).<span class="built_in">put</span>(<span class="number">65</span>).<span class="built_in">put</span>(<span class="string">'\n'</span>); <span class="comment">//显示字符:WA</span></span><br><span class="line"><span class="built_in">cout</span>.<span class="built_in">write</span>(<span class="string">"Hezil"</span>, <span class="number">3</span>);      <span class="comment">//显示字符串:Hez</span></span><br></pre></td></tr></table></figure></li><li><p>endl, ends, flush;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; ends &lt;&lt; <span class="string">"world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">flush</span> &lt;&lt; <span class="string">"world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-使用cin进行输入"><a class="markdownIt-Anchor" href="#2-使用cin进行输入"></a> 2. 使用cin进行输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">int</span> &amp;);</span><br></pre></td></tr></table></figure><p><code>istream</code>类还为下列字符指针类型重载了&gt;&gt;抽取运算符；</p><ul><li>signed char *;</li><li>char *;</li><li>unsigned char *;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;val)<span class="comment">//判断输入是否为int类型</span></span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>流状态</p><p><code>cin</code>或者<code>cout</code>包含一个描述流状态（stream state）的数据成员（从<code>ios_base</code>类继承而来），由三个<code>ios_base</code>元素组成：<code>eofbit</code>、<code>badbit</code>、<code>failbit</code>。</p><ul><li><p><code>eofbit</code></p><p>如果到达文件尾，则设置为1</p></li><li><p><code>badbit</code></p><p>如果流被破坏，则设置为1，例如：文件读取错误</p></li><li><p><code>failbit</code></p><p>如果输入操作未能读取预期的字符或输出操作没有写入预期的字符，则设置为1；</p></li></ul><p><strong>设置流状态：</strong></p><ul><li><pre class="highlight"><code class="c++"><span class="built_in">clear</span>();<span class="comment">//清楚全部三个状态位</span><span class="built_in">clear</span>(eofbit);setstate(eofbit);&lt;!--￼<span class="number">6</span>--&gt;</code></pre></li></ul></li><li><p>其他istream方法</p><ul><li><p>单字符输入</p><ul><li><code>get(char &amp;)</code>，返回类型为<code>istream &amp;</code>, 到达文件尾的返回值转化为false</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch,ch1;</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch).<span class="built_in">get</span>(ch1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>(ch))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//process input;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>get(void)</code>，返回类型为<code>int</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;<span class="comment">//or char ch</span></span><br><span class="line">ch = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch=<span class="built_in">cin</span>.<span class="built_in">get</span>())!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数适用于放置输入字符串的内存单元地址，第二个参数比要读取的最大字符数大一（额外的一个字符用于存储结尾的空字符串），第三个参数指定用作分界符的字符，只有两个参数的版本将换行符作为默认分界符。</p><ul><li><code>getline()</code></li><li><code>get()</code></li><li><code>ignore()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">ignore</span><span class="params">(<span class="keyword">int</span> =<span class="number">1</span>, <span class="keyword">int</span> = EOF)</span></span>;</span><br></pre></td></tr></table></figure><p>​默认参数<strong>EOF</strong>导致<code>ignore()</code>读取指定数目的字符或读取到文件未。</p></li></ul></li></ul><h3 id="3-文件输入和输出"><a class="markdownIt-Anchor" href="#3-文件输入和输出"></a> 3. 文件输入和输出</h3><ul><li><p>写入文件流程</p><ol><li>创建一个<code>ofstream</code>对象来管理输出流；</li><li>将该对象与特定的文件关联起来；</li><li>以使用<code>cout</code>的方式使用该对象，唯一的区别是输出将进文件而不是屏幕；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">"jar.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"jar.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">fout.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure></li><li><p>读取文件流程</p><ol><li>创建一个<code>ifstream</code>对象来管理输入流；</li><li>将对象与特定的文件关联；</li><li>以使用<code>cin</code>的方式使用该对象；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin;</span><br><span class="line">fin.<span class="built_in">open</span>(<span class="string">"jar.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"jar.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">fin.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li><li><p>检查文件是否被打开：</p><p><code>if (fin.is_open())</code></p></li><li><p><strong>文件模式</strong></p><p>文件模式描述的是文件将被如何使用：读、写、追加等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"filename"</span>, mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"filename"</span>, mode)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>文件模式常量</strong></p><ul><li><code>ios_base::in</code>：打开文件，以便读取。</li><li><code>ios_base::out</code>：打开文件，以便写入</li><li><code>os_base::ate</code>：打开文件，并移到文件尾</li><li><code>ios_base::app</code>：追加到文件尾</li><li><code>ios_base::binary</code>：二进制文件</li><li><code>ios_base::trunc</code>：如果文件存在，则截短文件(以前的内容将被删除)；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"jas.txt"</span>, ios_base::out | ios_base::app)</span></span>;</span><br><span class="line"><span class="comment">//合并模式，启用out和app模式</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="暂时写到这里其实这里的知识很多很复杂"><a class="markdownIt-Anchor" href="#暂时写到这里其实这里的知识很多很复杂"></a> 暂时写到这里，其实这里的知识很多很复杂…</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I/O（Input/Output），C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。&lt;/p&gt;
&lt;p&gt;这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。&lt;/p&gt;
&lt;p&gt;为了支持不同类型的IO处理操作，C++的IO类型
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ | 类大小问题(size of Class)</title>
    <link href="http://yoursite.com/2020/04/03/C++_%E7%B1%BB%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/03/C++_%E7%B1%BB%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-03T02:23:56.000Z</published>
    <updated>2020-04-07T07:09:48.710Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面向对象编程</strong>（OOP，Object Oriented Programming）是一种特殊的、设计程序的概念性方法。</p><p>C<ins>中的Class则是实现这一方法的重要组成部分，类是 C</ins> 的核心特性，通常被称为用户定义的类型。指定基本类型完成了三项工作：</p><ul><li>决定数据对象需要的内存数量；</li><li>决定如何解释内存中的位；</li><li>决定可使用数据对象执行的操作或方法；</li></ul><h3 id="1-class大小相关因素"><a class="markdownIt-Anchor" href="#1-class大小相关因素"></a> 1. Class大小相关因素</h3><p>类的大小与它的构造函数、析构函数以及其他成员函数无关，只与它的数据成员相关。</p><ul><li><p>有关因素</p><p><strong>普通成员变量，虚函数、继承</strong>（单一继承，多重继承，重复继承，虚拟继承）</p></li><li><p>无关因素</p><p>静态成员你变量、静态成员函数、普通成员函数</p></li></ul><h3 id="2-空类"><a class="markdownIt-Anchor" href="#2-空类"></a> 2. 空类</h3><p>空类即什么都没有的类，按上面的说法，照理说大小应该是0，但是，空类的大小为1，因为空类可以实例化，类的实例化就是为每个实例在内存中分配一块地址；每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会隐含地为其添加一个字节，以作区分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">empty_Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(empty_Class);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>继承空类的话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>:</span> <span class="keyword">public</span> empty_Class</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(base1);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>base1类的大小为4，base1类的大小是自身int成员变量的大小，至于为什么没有加上父类的大小1是因为空白基优化的问题，在空基类被继承后，子类会<strong>优化掉基类的1字节的大小</strong>，节省了空间大小，提高了运行效率。</p><h3 id="3-一般类大小"><a class="markdownIt-Anchor" href="#3-一般类大小"></a> 3. 一般类大小</h3><p>在类的定义中，因为不同类型声明顺序的不同，会导致不同的内存构造，因此类的大小会产生变化，所以应注意<strong>字节对齐</strong>，进而优化类的对象空间分布；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(baseA);<span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(baseB);<span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>baseA:</p><p><img src="baseA.jpg" alt="图片加载中"></p><p>baseB:</p><p><img src="baseB.jpg" alt="图片加载中"></p><h3 id="4-虚函数类"><a class="markdownIt-Anchor" href="#4-虚函数类"></a> 4. 虚函数类</h3><p>当一个类中包含虚函数时，会有一个指向其虚函数表的指针<strong>vptr</strong>，系统为类指针分配大小为4个字节(即使有多个虚函数)。（64位，指针大小8字节）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(virtual_A);<span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>基类Base中含有一个char型成员变量，以及两个虚函数，此时Base类的内存布局如下：</p><p><img src="20180503185905354.jpg" alt="图片加载中"></p><p>内存布局的最一开始是<strong>vfptr</strong>（virtual function ptr）即虚函数表指针（只要含虚函数，一定有虚函数表指针，而且该指针<strong>一定位于类内存模型最前端</strong>），接下来是Base类的成员变量，按照在类里的声明顺序排列，注意内存对齐原则！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(Derived);<span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>继承类Derived继承了基类，重写了Base中的虚函数f()，还添加了自己的成员变量，即int型的b，这时，Derived的类内存模型如下：</p><p><img src="20180503190906435.jpg" alt></p><h3 id="5-虚函数继承"><a class="markdownIt-Anchor" href="#5-虚函数继承"></a> 5. 虚函数继承</h3><p>32位下，<strong>vfptr</strong>（virtual function ptr）即虚函数表指针大小为4个字节</p><p>虚函数类的继承，<strong>派生类大小</strong>=派生类自身成员大小+基类数据成员大小+<strong>虚拟指针大小</strong>，（即使继承多个虚基类，也只有一个指向其虚函数表的指针vptr，大小为4字节）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(A); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">sizeof</span>(B); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;面向对象编程&lt;/strong&gt;（OOP，Object Oriented Programming）是一种特殊的、设计程序的概念性方法。&lt;/p&gt;
&lt;p&gt;C&lt;ins&gt;中的Class则是实现这一方法的重要组成部分，类是 C&lt;/ins&gt; 的核心特性，通常被称为用户定义
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2020/04/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-02T06:46:06.000Z</published>
    <updated>2020-04-02T08:07:03.585Z</updated>
    
    <content type="html"><![CDATA[<p><strong>排序</strong>（sorting）是将一组数据，按特定规则调换位置，使得数据具有某种顺序关系。</p><h3 id="1-冒泡排序"><a class="markdownIt-Anchor" href="#1-冒泡排序"></a> 1. 冒泡排序</h3><p><strong>冒泡排序</strong>（Bubble Sort）又称为交换排序法，每一次从当前最大的元素移动到列表的最右端，保证最右端的元素始终最大。冒泡排序法的时间复杂度为<code>O(n^2)</code>，这种排序算法适用于数据量小或有部分数据已经排序过，排序过程中为相邻两者互相比较和对调，并不会改变其原本排列的顺序，所以是稳定排序法。</p><p><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="图片加载中..."></p><p><strong>code:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="comment"># 遍历所有数组元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] :</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">arr = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">bubbleSort(arr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"排序后的数组:"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"%d"</span> %arr[i], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a class="markdownIt-Anchor" href="#2-选择排序"></a> 2. 选择排序</h3><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中<strong>选出</strong>最小（或最大）的一个元素，存放在序列的起始位置。</p><p><img src="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="图片加载中..."></p><p><strong>code:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># print(arr[i])</span></span><br><span class="line">        min_temp = arr[i]</span><br><span class="line">        temp_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; min_temp:</span><br><span class="line">                min_temp = arr[j]</span><br><span class="line">                temp_index = j</span><br><span class="line">        arr[temp_index],arr[i] = arr[i],min_temp</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">select_sort(arr)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"排序后的数组:"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">    print(<span class="string">"%d"</span> % arr[i], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a class="markdownIt-Anchor" href="#3-插入排序"></a> 3. 插入排序</h3><p><strong>插入排序</strong>（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="图片加载中..."></p><p><strong>code:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">insertionSort(arr)</span><br><span class="line">print(<span class="string">"排序后的数组:"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">    print(<span class="string">"%d"</span> % arr[i], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="4-希尔排序"><a class="markdownIt-Anchor" href="#4-希尔排序"></a> 4. 希尔排序</h3><p><strong>希尔排序</strong>（Shell Sort）是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><h5 id="未完待续"><a class="markdownIt-Anchor" href="#未完待续"></a> …未完待续</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;（sorting）是将一组数据，按特定规则调换位置，使得数据具有某种顺序关系。&lt;/p&gt;
&lt;h3 id=&quot;1-冒泡排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-冒泡排序&quot;&gt;&lt;/a&gt; 1. 冒泡排序&lt;/
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>python | python笔记</title>
    <link href="http://yoursite.com/2020/04/01/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/01/python%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-01T12:36:12.000Z</published>
    <updated>2020-04-03T02:27:01.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-eval"><a class="markdownIt-Anchor" href="#1-eval"></a> 1. eval</h3><p>eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。即变量赋值时，等号右边的表示是写成字符串的格式，返回值就是这个表达式的结果。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><ul><li>expression – 表达式。</li><li>globals – 变量作用域，全局命名空间，如果被提供，则必须是<strong>一个字典对象</strong>。</li><li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul><ol><li><p>简单表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(eval(<span class="string">'1 + 2'</span>))<span class="comment"># 3</span></span><br><span class="line">print(eval(<span class="string">'(1 + 2) * 3'</span>))<span class="comment"># 9</span></span><br></pre></td></tr></table></figure></li><li><p>传递全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(eval(<span class="string">"&#123;'name':'linux','age':age&#125;"</span>,&#123;<span class="string">"age"</span>:<span class="number">1822</span>&#125;))</span><br><span class="line"><span class="comment"># &#123;'name': 'linux', 'age': 1822&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>传递本地变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age=<span class="number">18</span></span><br><span class="line">print(eval(<span class="string">"&#123;'name':'linux','age':age&#125;"</span>,&#123;<span class="string">"age"</span>:<span class="number">1822</span>&#125;,locals()))</span><br><span class="line"><span class="comment"># &#123;'name':'linux','age':18&#125;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-eval&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-eval&quot;&gt;&lt;/a&gt; 1. eval&lt;/h3&gt;
&lt;p&gt;eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。即变量赋值时，等号右边的表示是写
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python | python命名空间和作用域</title>
    <link href="http://yoursite.com/2020/04/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/04/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-04-01T12:00:10.000Z</published>
    <updated>2020-04-03T02:27:23.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-命名空间"><a class="markdownIt-Anchor" href="#1-命名空间"></a> 1. 命名空间</h3><p>命名空间(namespace)一词，时常出现在C/C++程序开发中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>所谓namespace，是指标识符的各种可见范围。C++标准程序库中的所有标识符都被定义于一个名为<strong>std</strong>的namespace中。我们一般用命名空间来区分同名的不同变量或函数。</p><p>在python的学习中，无意间命名空间的概念在一定程度上被弱化。实际上，在python同样存在着命名空间的概念，命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p><p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p><p>python中一般有三种命名空间：</p><ul><li><strong>内置名称（built-in names）</strong>， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</li></ul><p>python中命名空间查找顺序：<strong>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p><p>python的全局名字空间存储在一个叫**globals()<strong>的dict对象中；局部名字空间存储在一个叫</strong>locals()**的dict对象中。可以用print (locals())来查看该函数体内的所有变量名和变量值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"局部作用域下："</span>)</span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line">print(<span class="string">"全局作用域下："</span>)</span><br><span class="line">print(globals())</span><br><span class="line">print(locals())</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">全局作用域下：</span><br><span class="line">&#123;...（省略很多信息）, 'n': 1, 'test': &lt;function test at 0x00000182E55E3E18&gt;&#125;</span><br><span class="line">&#123;...（省略很多信息）, 'n': 1, 'test': &lt;function test at 0x00000182E55E3E18&gt;&#125;</span><br><span class="line">局部作用域下：</span><br><span class="line">&#123;'n': 2&#125;</span><br></pre></td></tr></table></figure><p>命名空间的生命周期：</p><p>命名空间的生命周期取决于对象的<strong>作用域</strong>，如果对象执行完成，则该命名空间的生命周期就结束。因此，我们无法从外部命名空间访问内部命名空间的对象。</p><h3 id="2-作用域"><a class="markdownIt-Anchor" href="#2-作用域"></a> 2. 作用域</h3><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python作用域一共4种，分别是：</p><ul><li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数/方法内部。</li><li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类）A里面又包含了一个函数B，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li><li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li><li><strong>B（Built-in）</strong>：包含了内建的变量/关键字等，最后被搜索。</li></ul><p>查找顺序： <strong>L –&gt; E –&gt; G –&gt; B</strong></p><p>python引入新的作用域：</p><p><strong>只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域</strong>，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line">print(i)</span><br><span class="line"><span class="comment">#以下为输出结果</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>而在C/C++中，代码块中的局部变量会随着代码块的运行结束而释放，不能访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i;   <span class="comment">// 出错：'i' was not declared in this scope</span></span><br></pre></td></tr></table></figure><p>当内部作用域想修改外部作用域的变量时，就要用到<strong>global</strong>和<strong>nonlocal</strong>关键字了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num<span class="comment">#global声明num变量为全局变量</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">print(num)<span class="comment"># 1  </span></span><br><span class="line">change_num()</span><br><span class="line">print(num)<span class="comment"># 100</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_num</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        num = <span class="number">10</span><span class="comment"># 仅改变了enclosing作用域，外层非全局作用域</span></span><br><span class="line">    print(num)<span class="comment"># 100</span></span><br><span class="line">    inner()</span><br><span class="line">    print(num)<span class="comment"># 10</span></span><br><span class="line">change_num()</span><br><span class="line">print(num) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-命名空间&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-命名空间&quot;&gt;&lt;/a&gt; 1. 命名空间&lt;/h3&gt;
&lt;p&gt;命名空间(namespace)一词，时常出现在C/C++程序开发中。&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-03-31T06:11:07.000Z</published>
    <updated>2020-03-31T08:24:35.004Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有<strong>重复子问题</strong>和<strong>最优子结构</strong>的问题。</p><ul><li><p>如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就具备<strong>最优子结构</strong></p></li><li><p>如果计算最优解时需要处理很多相同的问题，那么这个问题就具备<strong>重复子问题</strong></p></li></ul><p>当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个<strong>memory</strong>来缓存重复子问题的结果，<strong>避免了递归的过程中的大量的重复计算</strong>。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的。</p><p>当要应用动态规划来解决问题时，归根结底就是想办法完成以下三个关键目标。</p><ol><li>建立状态转移方程</li></ol><p>这一步通常是最难的…，状态之间的关系。例如<strong>斐波那契数列</strong>，状态转移方程为：<code>f(n)=f(n-1)+f(n-2)</code></p><ol start="2"><li><p>缓存把那个复用以往结果</p></li><li><p>按顺序从小往大算</p></li></ol><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例：</h3><p>看看最简单的斐波那契数列：0,1,1,2,3 … 从第0项开始，<code>f(n) = f(n-1)+f(n-2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统的递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划形式#1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_1</span><span class="params">(n)</span>:</span></span><br><span class="line">    memory = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        memory.append(memory[i - <span class="number">1</span>] + memory[i - <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划#2递归形式</span></span><br><span class="line">memory = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp_2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    <span class="keyword">if</span> n &gt;= len(memory):</span><br><span class="line">        memory.append(fibo_dp_2(n - <span class="number">1</span>) + fibo_dp_2(n - <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br></pre></td></tr></table></figure><p>当计算的数较小时：三种方式花费时间差距并不大：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span>, res = <span class="number">55</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">0.000063</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000011</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000014</span>sec</span><br></pre></td></tr></table></figure><p>当计算的数较大时，耗时差距就体现出来，动态规划<strong>缓存</strong>的重要性便凸显出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">37</span>, res = <span class="number">24157817</span></span><br><span class="line"><span class="number">1</span>: time cost:<span class="number">16.511701</span>sec</span><br><span class="line"><span class="number">2</span>: time cost:<span class="number">0.000026</span>sec</span><br><span class="line"><span class="number">3</span>: time cost:<span class="number">0.000044</span>sec</span><br></pre></td></tr></table></figure><p>动态规划速度的快，是因为它将之前的小问题的结果保存在缓存中，而传统的递归方式，相当于重复计算小问题，因此耗时。</p><p><img src="%E4%BC%A0%E7%BB%9F%E9%80%92%E5%BD%92.jpg" alt="image-20200331161524036"></p><p>当然这只是动态规划的最简单形式，动态规划的Leetcode专栏：</p><p><a href="https://leetcode-cn.com/tag/dynamic-programming/" target="_blank" rel="noopener">leetcode/动态规划</a></p><p>唉…我太菜了，很多时候找不到状态转移关系…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划(dynamic planning)是一种高效解决问题的方法，适用于具有&lt;strong&gt;重复子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>A-star算法</title>
    <link href="http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/A-star%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T05:09:56.000Z</published>
    <updated>2020-03-30T08:01:28.574Z</updated>
    
    <content type="html"><![CDATA[<p>A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。</p><blockquote><p>本文动图、内容来源：<a href="https://www.jianshu.com/u/12532d36e4da" target="_blank" rel="noopener">阿里云云栖号</a></p></blockquote><h3 id="路径规划的一些算法"><a class="markdownIt-Anchor" href="#路径规划的一些算法"></a> 路径规划的一些算法</h3><ol><li>广度优先搜索算法</li></ol><p>BFS（Breadth first search）从起点开始，首先遍历起点周围临近点，然后在遍历已经遍历过的点未访问过的临近点，逐步向外扩散，直到找到终点。BFS以广度为优先级进行搜索。</p><p><img src="BFS" alt="图片加载中"></p><ol start="2"><li>dijkstra算法</li></ol><p>Dijkstra算法用来寻找图形中节点之间的最短路径。Dijkstra算法可以视作BFS算法的带权版本，增加了路径代价的概念。算法执行过程中，每次都从优先级队列中选出代价最小的作为下一个点，直到到达终点。</p><p><img src="dijkstra" alt></p><ol start="3"><li>最佳优先搜索</li></ol><p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p><p>与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p><p><img src="bestfs_good" alt></p><p>但是这样也会出现不良情况，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</p><p><img src="bestfs_bad" alt></p><h3 id="a算法"><a class="markdownIt-Anchor" href="#a算法"></a> A*算法</h3><p>A*算法实际上是综合上面这些算法的特点于一身的。</p><p>A*算法通过下面这个函数来计算每个节点的优先级。</p><p><code>f(n)=g(n)+h(n)</code></p><p>在上式中：</p><ul><li><code>f(n)</code>为节点n的综合优先级；</li><li><code>g(n)</code>为节点n距离起点的代价；</li><li><code>h(n)</code>为节点n距离终点的预计代价。</li></ul><p>上式即为A*算法的启发函数。A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。</p><p>另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为<code>open_set</code>和<code>close_set</code>。完整的A*算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 初始化open_set和close_set；</span><br><span class="line">* 将起点加入open_set中，并设置优先级为0（优先级最高）；</span><br><span class="line">* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span><br><span class="line">    * 如果节点n为终点，则：</span><br><span class="line">        * 从终点开始逐步追踪parent节点，一直达到起点；</span><br><span class="line">        * 返回找到的结果路径，算法结束；</span><br><span class="line">    * 如果节点n不是终点，则：</span><br><span class="line">        * 将节点n从open_set中删除，并加入close_set中；</span><br><span class="line">        * 遍历节点n所有的邻近节点：</span><br><span class="line">            * 如果邻近节点m在close_set中，则：</span><br><span class="line">                * 跳过，选取下一个邻近节点</span><br><span class="line">            * 如果邻近节点m也不在open_set中，则：</span><br><span class="line">                * 设置节点m的parent为节点n</span><br><span class="line">                * 计算节点m的优先级</span><br><span class="line">                * 将节点m加入open_set中</span><br></pre></td></tr></table></figure><p>上面已经提到，启发函数会影响A*算法的行为。</p><ul><li>在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时<strong>算法就退化成了Dijkstra算法</strong>。</li><li>如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。</li><li>如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li><li>如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li><li>在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。</li></ul><p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p><p>对于网格形式的图，有以下这些启发函数可以使用：</p><ul><li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。<code>C</code>为移动代价</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> C * (dx+dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝八个方向移动，则可以使用对角距离。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(node)</span>:</span></span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    <span class="keyword">return</span> D * (dx + dy) + (D2 - <span class="number">2</span> * D) * min(dx, dy)</span><br></pre></td></tr></table></figure><ul><li>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</li></ul><h3 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性：</h3><p>虽然 Ａ ＊ 算法能有效解决最短路径问题，但其存在易陷入“死循环”、规划路径折点多、在动态环境中规划效果不佳等问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A*算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。&lt;/p&gt;
&lt;blo
      
    
    </summary>
    
    
    
      <category term="A*" scheme="http://yoursite.com/tags/A/"/>
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/30/Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-30T01:11:56.000Z</published>
    <updated>2020-04-06T14:10:17.844Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中<strong>不存在负权边</strong>。用于求图中指定两点之间的<strong>最短路径</strong>，或者是<strong>指定一点到其它</strong>所有点之间的最短路径。实质上是<strong>贪心算法</strong>。</p><p>Dijkstra算法可以说是BFS（宽度优先搜索算法）的升级版，BFS的实现可以依靠队列实现，而Dijkstra算法可以通过优先级队列进行实现。</p><p><img src="2012073019540660.gif" alt="图片加载中"></p><h3 id="1-算法描述"><a class="markdownIt-Anchor" href="#1-算法描述"></a> 1. 算法描述</h3><p><strong>Dijkstra算法</strong>利用贪心策略，从起始点开始出发，选择距离当前位置最近的点加入路径。</p><p>因此算法用到两个集合：</p><ol><li>当前路径中已有点的集合</li><li>当前路径中未包含点的集合</li></ol><p>**原理：**Dijkstra的大致思想就是，根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合，集合中所有的点的d[i]都是该点到初始点最短路径长度，由于后加入的点是根据集合S中的点为基础拓展的，所以也能找到最短路径。</p><p>1.将图上的初始点看作一个集合S，其它点看作另一个集合</p><p>2.根据初始点，求出其它点到初始点的距离d[i] （若相邻，则d[i]为边权值；若不相邻，则d[i]为无限大）</p><p>3.选取最小的d[i]（记为d[x]），并将此d[i]边对应的点（记为x）加入集合S</p><p>4.再根据x，更新跟 x 相邻点 y 的d[y]值：d[y] = min{ d[y], d[x] + 边权值w[x][y] }，因为可能把距离调小，所以这个更新操作叫做<strong>松弛操作</strong>。</p><p>5.重复3，4两步，直到目标点也加入了集合，此时目标点所对应的d[i]即为最短路径长度。</p><p>较好理解的视频：（用优先级队列实现）</p><p><a href="https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ts41157Sy?from=search&amp;seid=18117383376943679146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，注意该算法要求图中&lt;strong&gt;不存在负权边&lt;/strong&gt;。
      
    
    </summary>
    
    
    
      <category term="路径规划" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>测试图片</title>
    <link href="http://yoursite.com/2020/03/29/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2020/03/29/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</id>
    <published>2020-03-29T11:27:06.000Z</published>
    <updated>2020-03-29T14:16:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片</p><p><img src="zentree_1.png" alt="zentree_1"><br><img src="zentree_1.png" alt="zentree_1"></p><p><img src="test.jpg" alt="zentree_1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上传图片本文用于测试上
      
    
    </summary>
    
    
    
      <category term="测试图片" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="http://yoursite.com/2020/03/29/hello/"/>
    <id>http://yoursite.com/2020/03/29/hello/</id>
    <published>2020-03-29T10:49:59.000Z</published>
    <updated>2020-04-09T13:36:22.534Z</updated>
    
    <content type="html"><![CDATA[<p>今天成功利用hexo构建个人博客，由GitHub page进行托管</p><h3 id="测试公式渲染"><a class="markdownIt-Anchor" href="#测试公式渲染"></a> 测试公式渲染</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>x</mi><mi>o</mi><mo>=</mo><msubsup><mo>∑</mo><mrow></mrow><mrow></mrow></msubsup><mi>s</mi><mi>d</mi><mi>f</mi><mi>a</mi><mi>s</mi><mi>d</mi><mi>f</mi><mi>a</mi><mi>s</mi><mo>×</mo></mrow><annotation encoding="application/x-tex">hexo=\sum_{}^{}sdfasdfas \times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.3500050000000001em;"></span><span class="strut bottom" style="height:2.60001em;vertical-align:-1.250005em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mord mathit">o</span><span class="mrel">=</span><span class="mop op-limits"><span class="vlist"><span style="top:1.150005em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"></span></span></span><span style="top:-0.000005000000000032756em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span style="top:-1.250005em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">s</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mbin">×</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo>(</mo><msubsup><mi>σ</mi><mrow><mi>i</mi></mrow><mi>x</mi></msubsup><msubsup><mi>σ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>x</mi></msubsup><mo>+</mo><mi>g</mi><msubsup><mi>σ</mi><mrow><mi>i</mi></mrow><mi>z</mi></msubsup><mo>)</mo></mrow><annotation encoding="application/x-tex">H=-\sum_{i=1}^N (\sigma_{i}^x \sigma_{i+1}^x+g \sigma_{i}^z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.8283360000000002em;"></span><span class="strut bottom" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord">−</span><span class="mop op-limits"><span class="vlist"><span style="top:1.1776689999999999em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.000005000000000143778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span style="top:-1.2500050000000003em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.247em;margin-left:-0.03588em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span style="top:-0.4129999999999999em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.24700000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.41300000000000003em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.247em;margin-left:-0.03588em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span style="top:-0.4129999999999999em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>1</mn><mn>1</mn><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">11111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>d</mi><mi>f</mi><mi>a</mi><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">sdfafa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span></span></span></span></span></p><p>11111111111</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0em;"></span><span class="strut bottom" style="height:0em;vertical-align:0em;"></span><span class="base displaystyle textstyle uncramped"></span></span></span></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天成功利用hexo构建个人博客，由GitHub page进行托管&lt;/p&gt;
&lt;h3 id=&quot;测试公式渲染&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#测试公式渲染&quot;&gt;&lt;/a&gt; 测试公式渲染&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;katex-
      
    
    </summary>
    
    
    
      <category term="启程" scheme="http://yoursite.com/tags/%E5%90%AF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo | 博客搭建</title>
    <link href="http://yoursite.com/2020/03/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/03/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-03-29T04:00:00.000Z</published>
    <updated>2020-04-09T15:21:33.729Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">HEXO</a>：快速、简洁且高效的博客框架</p><h3 id="1-hexo安装"><a class="markdownIt-Anchor" href="#1-hexo安装"></a> 1. HEXO安装</h3><ul><li>安装Git</li></ul><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>下载速度感人，可以选择<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">国内镜像</a>下载git，然后安装…</p><ul><li>安装node.js</li></ul><p>Hexo是基于NodeJS环境的静态博客，搭建基本全靠npm，npm是随同NodeJS一起安装的包管理工具。<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node.js</a>下载，安装…</p><p>npm全称Node Package Manager，是node.js的模块依赖管理工具。由于<code>npm</code>的源在国外，所以国内用户使用起来各种不方便。配置国内淘宝npm镜像方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 永久配置</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash">or</span></span><br><span class="line">npm config ls</span><br></pre></td></tr></table></figure><ul><li>安装<strong>hexo</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -g全局安装</span></span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><ul><li>初始化hexo博客目录</li></ul><p>选择你想要的存放博客本地文件路径，根据实际情况执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog   # 将会新建一个blog的文件夹，最后hexo项目的初始化位置</span><br><span class="line"><span class="meta">#</span><span class="bash"> or 如果你想把当前所在文件夹作为hexo库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hexo init</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上述命令可以克隆基本的hexo框架以及主题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后在blog目录下</span></span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>即可预览初始化的hexo博客，到这里你已经初步搭建好你的博客框架</p><p><img src="image-20200409221434191.png" alt="image-20200409221434191"></p><p>在blog目录下，存在以下文件夹和文件：</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><h3 id="2-配置博客信息"><a class="markdownIt-Anchor" href="#2-配置博客信息"></a> 2. 配置博客信息</h3><p>打开博客主目录下的<code>_config.yml</code>文件，修改或者添加配置参数。</p><p>同时，进入<code>themes</code>目录下的主题文件夹，修改<code>_config.yml</code>，同样配置信息。</p><p>在此过程中，需要阅读相关说明文档（例如主题的说明文档）</p><h3 id="3-写博客"><a class="markdownIt-Anchor" href="#3-写博客"></a> 3. 写博客</h3><ul><li>新建博文，在博客主目录中执行：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new xxx#xxx为你的博客名称</span><br></pre></td></tr></table></figure><p>然后打开<code>source/_post</code>打开创建的<code>xxx.md</code>，编辑即可；</p><ul><li>上传博文到服务器</li></ul><p>在主目录中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean# 清楚之前生成的网站文件</span><br><span class="line">hexo generate # 生成网站文件</span><br><span class="line">hexo server# 预览</span><br></pre></td></tr></table></figure><h3 id="4-博客中上传图片"><a class="markdownIt-Anchor" href="#4-博客中上传图片"></a> 4. 博客中上传图片</h3><ul><li><p>首先编辑主目录中配置文档<code>_config.yml</code>，修改<code>post_asset_folder</code>属性为：<code>true</code></p></li><li><p>安装插件<code>hexo-asset-image</code>，在主目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>此时使用<code>hexo new xxx</code>时候，在<code>source/_post</code>目录下生成md文件的同时，也会产生一个同名文件夹，该文件夹用于放置对应博文图片。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># markdown添加图片格式</span></span><br><span class="line"><span class="section"># ![图片说明](图片路径)</span></span><br><span class="line">![<span class="string">图片</span>](<span class="link">xxx/xxx.jpg</span>)</span><br></pre></td></tr></table></figure></li><li><h3 id="这里po一个我遇到的问题"><a class="markdownIt-Anchor" href="#这里po一个我遇到的问题"></a> <em>这里po一个我遇到的问题</em></h3><p>上传之后，发现网页没有正确加载图片，查看网页代码，发现路径很奇怪…之后，我修改<code>hexo-asset-image</code>插件中的<code>index.js</code>文件中的一处代码，才解决问题：</p><p><code>node_modules/hexo-asset-image/index.js</code>的58行改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, src);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-公式支持"><a class="markdownIt-Anchor" href="#5-公式支持"></a> 5. 公式支持</h3><p>基于Hexo搭建的个人博客，默认情况下渲染数学公式会产生一些问题，我遇到的便是无法渲染。Hexo默认使用<code>hexo-renderer-marked</code>引擎渲染markdown，最理想的办法便是替换渲染引擎。</p><p>参考：</p><ol><li><p><a href="https://blog.cofess.com/2017/09/06/how-to-use-mathjax-to-render-latex-mathematical-formula-in-hexo.html" target="_blank" rel="noopener">如何在Hexo中使用Mathjax渲染LaTeX数学公式</a></p></li><li><p><a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus" target="_blank" rel="noopener">项目主页</a></p></li></ol><ul><li><p>安装<code>hexo-renderer-markdown-it-plus</code>插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-markdown-it-plus --save</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一些依赖</span></span><br><span class="line">npm install markdown-it-katex --save</span><br><span class="line">npm install markdown-it-mark --save</span><br></pre></td></tr></table></figure></li><li><p>配置</p><p>打开主目录博客配置文档<code>_config.yml</code>，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">markdown_it_plus:</span><br><span class="line">  highlight: true</span><br><span class="line">  html: true</span><br><span class="line">  xhtmlOut: true</span><br><span class="line">  breaks: true</span><br><span class="line">  langPrefix:</span><br><span class="line">  linkify: true</span><br><span class="line">  typographer:</span><br><span class="line">  quotes: “”‘’</span><br><span class="line">  pre_class: highlight</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin:</span><br><span class="line">        name: markdown-it-katex</span><br><span class="line">        enable: true</span><br><span class="line">    - plugin:</span><br><span class="line">        name: markdown-it-mark</span><br><span class="line">        enable: false</span><br></pre></td></tr></table></figure></li><li><p>网页加载CSS</p><p>修改主题网页生成相关文件代码，确保网页<code>head</code>部分加载mathjax样式表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>公式示例</p><p>段落内公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a=b+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mbin">+</span><span class="mord mathit">c</span></span></span></span>， 字母：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>k</mi><mi>k</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">kkkk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span></p><p>居中公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo>(</mo><msubsup><mi>σ</mi><mrow><mi>i</mi></mrow><mi>x</mi></msubsup><msubsup><mi>σ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>x</mi></msubsup><mo>+</mo><mi>g</mi><msubsup><mi>σ</mi><mrow><mi>i</mi></mrow><mi>z</mi></msubsup><mo>)</mo></mrow><annotation encoding="application/x-tex">H=-\sum_{i=1}^N (\sigma_{i}^x \sigma_{i+1}^x+g \sigma_{i}^z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.8283360000000002em;"></span><span class="strut bottom" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord">−</span><span class="mop op-limits"><span class="vlist"><span style="top:1.1776689999999999em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.000005000000000143778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span style="top:-1.2500050000000003em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.247em;margin-left:-0.03588em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span style="top:-0.4129999999999999em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.24700000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.41300000000000003em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.247em;margin-left:-0.03588em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span style="top:-0.4129999999999999em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></span></p></li></ul><h3 id="6github"><a class="markdownIt-Anchor" href="#6github"></a> 6.github</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HEXO&lt;/a&gt;：快速、简洁且高效的博客框架&lt;/p&gt;
&lt;h3 id=&quot;1-hexo安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;
      
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
